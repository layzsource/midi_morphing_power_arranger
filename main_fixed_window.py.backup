import sys
import logging
import time
import threading
import colorsys
import numpy as np
import queue
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QWidget, QSlider, 
    QLabel, QComboBox, QStatusBar, QPushButton, QCheckBox, QMenuBar,
    QMenu, QMessageBox
)
from PySide6.QtCore import Qt, QSettings, QTimer, Signal, QObject
from PySide6.QtGui import QAction
from pyvistaqt import QtInteractor
import pyvista as pv

from config import Config
from geometry import create_initial_meshes, blend_meshes
from performance_monitoring import PerformanceProfiler, PerformanceDialog, performance_monitor
from config_dialog import ConfigurationDialog
from scene_manager import SceneManager
from scene_config_dialog import SceneConfigurationDialog

# FIXED: Import the safe color utilities
from color_utils import safe_hsv_to_rgb, safe_color_array, blend_colors_safe

# MIDI imports
try:
    import pygame
    import pygame.midi
    MIDI_AVAILABLE = True
    print("Using pygame for MIDI support")
except ImportError:
    MIDI_AVAILABLE = False
    print("pygame not available - MIDI disabled")

# Audio imports
try:
    import pyaudio
    AUDIO_AVAILABLE = True
    print("Audio analysis available")
except ImportError:
    AUDIO_AVAILABLE = False
    print("Audio libraries not available - audio analysis disabled")

logger = logging.getLogger(__name__)

class AudioAnalyzer(QObject):
    """Audio analysis - only starts when explicitly enabled."""
    onset_detected_signal = Signal(float)
    amplitude_signal = Signal(float)
    
    def __init__(self, config):
        super().__init__()
        self.config = config
        self.audio = None
        self.stream = None
        self.running = False
        self.thread = None
        self.audio_queue = queue.Queue()
        
        self.sample_rate = config.AUDIO_SAMPLE_RATE
        self.chunk_size = config.AUDIO_CHUNK_SIZE
        
        # FIXED: Use the correct buffer size calculation instead of AUDIO_BUFFER_SIZE
        if hasattr(config, 'AUDIO_FFT_SIZE'):
            self.buffer_size = config.AUDIO_FFT_SIZE
        elif hasattr(config, 'AUDIO_BUFFER_SIZE'):
            self.buffer_size = config.AUDIO_BUFFER_SIZE
        else:
            # Fallback to a reasonable buffer size
            self.buffer_size = self.sample_rate * 2  # 2 seconds of audio
        
        self.audio_buffer = np.zeros(self.buffer_size)
        self.is_active = False
    
    @performance_monitor
    def start(self):
        if not AUDIO_AVAILABLE or self.is_active:
            return False
            
        try:
            self.audio = pyaudio.PyAudio()
            device_index = self._find_input_device()
            if device_index is None:
                return False
            
            self.stream = self.audio.open(
                format=pyaudio.paFloat32,
                channels=1,
                rate=self.sample_rate,
                input=True,
                input_device_index=device_index,
                frames_per_buffer=self.chunk_size,
                stream_callback=self._audio_callback
            )
            
            self.stream.start_stream()
            
            self.running = True
            self.is_active = True
            self.thread = threading.Thread(target=self._analysis_loop, daemon=True)
            self.thread.start()
            
            print("Audio analysis started")
            return True
            
        except Exception as e:
            print(f"Failed to start audio analysis: {e}")
            return False
    
    def stop(self):
        """Stop audio analysis completely."""
        self.running = False
        self.is_active = False
        
        if self.stream:
            self.stream.stop_stream()
            self.stream.close()
            self.stream = None
        
        if self.audio:
            self.audio.terminate()
            self.audio = None
        
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=1.0)
        
        print("Audio analysis stopped")
    
    def _find_input_device(self):
        """Find the best input device."""
        try:
            # Try default input device first
            try:
                default_device = self.audio.get_default_input_device_info()
                if default_device['maxInputChannels'] > 0:
                    print(f"Using default audio input: {default_device['name']}")
                    return default_device['index']
            except:
                pass
            
            # Fall back to first available input device
            for i in range(self.audio.get_device_count()):
                device_info = self.audio.get_device_info_by_index(i)
                if device_info['maxInputChannels'] > 0:
                    print(f"Using audio input: {device_info['name']}")
                    return i
            
            print("No audio input devices found")
            return None
            
        except Exception as e:
            print(f"Error finding audio device: {e}")
            return None
    
    def _audio_callback(self, in_data, frame_count, time_info, status):
        """Audio stream callback."""
        try:
            if status:
                print(f"Audio stream status: {status}")
            
            audio_data = np.frombuffer(in_data, dtype=np.float32)
            
            if not self.audio_queue.full():
                self.audio_queue.put(audio_data.copy())
            
            return (None, pyaudio.paContinue)
            
        except Exception as e:
            print(f"Audio callback error: {e}")
            return (None, pyaudio.paAbort)
    
    def _analysis_loop(self):
        """Main audio analysis loop."""
        while self.running:
            try:
                try:
                    audio_chunk = self.audio_queue.get(timeout=0.1)
                except queue.Empty:
                    continue
                
                self._update_buffer(audio_chunk)
                self._analyze_audio()
                
            except Exception as e:
                print(f"Audio analysis error: {e}")
    
    def _update_buffer(self, new_chunk):
        """Update the audio buffer with new data."""
        try:
            shift_amount = len(new_chunk)
            self.audio_buffer[:-shift_amount] = self.audio_buffer[shift_amount:]
            self.audio_buffer[-shift_amount:] = new_chunk
        except Exception as e:
            print(f"Buffer update error: {e}")
    
    @performance_monitor
    def _analyze_audio(self):
        """Analyze current audio buffer."""
        try:
            if np.max(np.abs(self.audio_buffer)) < 1e-6:
                return
            
            rms = np.sqrt(np.mean(self.audio_buffer ** 2))
            self.amplitude_signal.emit(rms)
            
            # Simple onset detection
            current_energy = np.sum(self.audio_buffer ** 2)
            if hasattr(self, 'previous_energy'):
                energy_ratio = current_energy / max(self.previous_energy, 1e-10)
                if energy_ratio > self.config.AUDIO_ONSET_THRESHOLD:
                    self.onset_detected_signal.emit(rms)
            
            self.previous_energy = current_energy
                
        except Exception as e:
            print(f"Audio analysis failed: {e}")

# ALSO FIXED: MidiHandler stop method to prevent the pygame.midi error
class MidiHandler(QObject):
    note_on_signal = Signal(int, float)
    note_off_signal = Signal(int)
    cc_signal = Signal(int, float)
    
    def __init__(self):
        super().__init__()
        self.midi_input = None
        self.running = False
        self.thread = None
        self.midi_initialized = False
        
    @performance_monitor
    def start(self, device_name=None):
        if not MIDI_AVAILABLE:
            return False
            
        try:
            if not self.midi_initialized:
                pygame.init()
                pygame.midi.init()
                self.midi_initialized = True
            
            device_id = None
            if device_name:
                # Find device by name
                for i in range(pygame.midi.get_count()):
                    info = pygame.midi.get_device_info(i)
                    name = info[1].decode() if isinstance(info[1], bytes) else str(info[1])
                    if name == device_name and info[2]:  # is_input
                        device_id = i
                        break
            
            if device_id is None:
                # Find any available input device
                for i in range(pygame.midi.get_count()):
                    info = pygame.midi.get_device_info(i)
                    if info[2]:  # is_input
                        device_id = i
                        break
            
            if device_id is not None:
                self.midi_input = pygame.midi.Input(device_id)
                self.running = True
                
                self.thread = threading.Thread(target=self._midi_loop)
                self.thread.daemon = True
                self.thread.start()
                
                print(f"MIDI started on device {device_id}")
                return True
            else:
                print("No MIDI input devices found")
                return False
                
        except Exception as e:
            print(f"MIDI initialization failed: {e}")
            return False
    
    def stop(self):
        """FIXED: Properly stop MIDI to prevent pygame.midi errors."""
        self.running = False
        
        # Close MIDI input first
        if self.midi_input:
            try:
                self.midi_input.close()
                self.midi_input = None
            except Exception as e:
                print(f"Error closing MIDI input: {e}")
        
        # Wait for thread to finish
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=1.0)
        
        # Only quit pygame.midi if we initialized it
        if self.midi_initialized:
            try:
                pygame.midi.quit()
                self.midi_initialized = False
            except Exception as e:
                print(f"Error quitting pygame.midi: {e}")
    
    def _midi_loop(self):
        """FIXED: MIDI loop with proper error handling."""
        while self.running:
            try:
                if self.midi_input and self.midi_input.poll():
                    events = self.midi_input.read(10)
                    for event in events:
                        self._process_midi_event(event[0])
                time.sleep(0.001)
            except Exception as e:
                if self.running:  # Only log if we're supposed to be running
                    print(f"MIDI loop error: {e}")
                break
    
    def _process_midi_event(self, event_data):
        """Process MIDI event data."""
        try:
            status, note, velocity, _ = event_data
            
            if status == 144 and velocity > 0:  # Note On
                self.note_on_signal.emit(note, velocity / 127.0)
            elif status == 128 or (status == 144 and velocity == 0):  # Note Off
                self.note_off_signal.emit(note)
            elif status == 176:  # Control Change
                self.cc_signal.emit(note, velocity / 127.0)
        except Exception as e:
            print(f"Error processing MIDI event: {e}")

class PerformanceAwareMainWindow(QMainWindow):
    """Main window with comprehensive performance monitoring and safe color handling."""
    
    def __init__(self):
        super().__init__()
        
        # Initialize configuration
        self.config = Config()
        
        # Performance monitoring
        self.profiler = PerformanceProfiler(self.config)
        self.profiler.start_monitoring()
        
        # Core state
        self.initial_meshes = {}
        self.current_mesh = None
        self.current_mesh_key = "sphere"
        self.target_mesh_key = "cube"
        self.actor = None
        self.default_color = np.array([0.7, 0.7, 0.7])
        
        # MIDI and audio state
        self.active_notes = {}
        self.audio_enabled = False
        self.audio_color_influence = 0.0
        self.audio_morph_influence = 0.0
        
        # Scene management
        self.scene_manager = None
        
        # Handlers
        self.midi_handler = None
        self.audio_analyzer = None
        
        # UI dialogs
        self.performance_dialog = None
        self.config_dialog = None
        self.scene_config_dialog = None
        
        # Initialize UI and systems
        self._setup_ui()
        self._setup_midi()
        self._setup_audio()
        self._setup_scene_manager()
        self._setup_performance_monitoring()
        self._setup_timers()
        
        # Load settings
        self._load_settings()
        
        print("Performance-aware main window initialized")
    
    def _setup_ui(self):
        """Setup UI with performance monitoring."""
        self.setWindowTitle("MIDI Morphing Visualizer - Performance Edition")
        
        # Create menu bar
        self._create_menu_bar()
        
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        layout = QVBoxLayout(central_widget)
        
        # 3D visualization
        self.plotter_widget = QtInteractor(self)
        self.plotter_widget.set_background("black")
        layout.addWidget(self.plotter_widget)
        
        # Control panel
        controls_layout = QVBoxLayout()
        
        # Morphing controls
        morph_group = QWidget()
        morph_layout = QVBoxLayout(morph_group)
        
        # Target shape selector
        shape_layout = QVBoxLayout()
        shape_layout.addWidget(QLabel("Target Shape:"))
        self.target_combo = QComboBox()
        self.target_combo.addItems(["sphere", "cube", "cone", "icosahedron", "torus"])
        self.target_combo.setCurrentText("cube")
        self.target_combo.currentTextChanged.connect(self.on_target_shape_change)
        shape_layout.addWidget(self.target_combo)
        morph_layout.addLayout(shape_layout)
        
        # Morph slider
        slider_layout = QVBoxLayout()
        slider_layout.addWidget(QLabel("Morph Amount:"))
        self.morph_slider = QSlider(Qt.Horizontal)
        self.morph_slider.setRange(0, 100)
        self.morph_slider.setValue(0)
        self.morph_slider.valueChanged.connect(self.on_morph_slider_change)
        slider_layout.addWidget(self.morph_slider)
        morph_layout.addLayout(slider_layout)
        
        controls_layout.addWidget(morph_group)
        
        # Audio controls
        audio_group = QWidget()
        audio_layout = QVBoxLayout(audio_group)
        
        self.audio_enabled_check = QCheckBox("Enable Audio Analysis")
        self.audio_enabled_check.toggled.connect(self._toggle_audio)
        audio_layout.addWidget(self.audio_enabled_check)
        
        controls_layout.addWidget(audio_group)
        
        # Utility buttons
        buttons_layout = QVBoxLayout()
        
        self.cleanup_button = QPushButton("Clean Up Expired")
        self.cleanup_button.clicked.connect(self._cleanup_expired_elements)
        buttons_layout.addWidget(self.cleanup_button)
        
        self.clear_button = QPushButton("Clear All")
        self.clear_button.clicked.connect(self._clear_all)
        buttons_layout.addWidget(self.clear_button)
        
        self.reconnect_midi_button = QPushButton("Reconnect MIDI")
        self.reconnect_midi_button.clicked.connect(self._reconnect_midi)
        buttons_layout.addWidget(self.reconnect_midi_button)
        
        controls_layout.addLayout(buttons_layout)
        
        layout.addLayout(controls_layout)
        
        # Status bar with performance indicators
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        
        # Performance indicators
        self.fps_label = QLabel("FPS: --")
        self.memory_label = QLabel("Mem: --%")
        self.notes_label = QLabel("Active Notes: None")
        self.audio_label = QLabel("Audio: Disabled")
        
        self.status_bar.addWidget(self.fps_label)
        self.status_bar.addWidget(self.memory_label)
        self.status_bar.addPermanentWidget(self.notes_label)
        self.status_bar.addPermanentWidget(self.audio_label)
        
        # Initialize 3D scene
        self._initialize_3d_scene()
    
    def _create_menu_bar(self):
        """Create application menu bar."""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        # Configuration submenu
        config_action = QAction("Settings...", self)
        config_action.triggered.connect(self._show_config_dialog)
        config_action.setShortcut("Ctrl+,")
        file_menu.addAction(config_action)
        
        file_menu.addSeparator()
        
        export_perf_action = QAction("Export Performance Data", self)
        export_perf_action.triggered.connect(self._export_performance_data)
        file_menu.addAction(export_perf_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("Exit", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # View menu
        view_menu = menubar.addMenu("View")
        
        # Scene configuration
        scene_config_action = QAction("Scene Configuration...", self)
        scene_config_action.triggered.connect(self._show_scene_config_dialog)
        scene_config_action.setShortcut("Ctrl+Shift+S")
        view_menu.addAction(scene_config_action)
        
        view_menu.addSeparator()
        
        # Performance menu
        perf_menu = menubar.addMenu("Performance")
        
        show_monitor_action = QAction("Show Performance Monitor", self)
        show_monitor_action.triggered.connect(self._show_performance_dialog)
        perf_menu.addAction(show_monitor_action)
        
        perf_menu.addSeparator()
        
        enable_monitoring_action = QAction("Enable Performance Monitoring", self)
        enable_monitoring_action.setCheckable(True)
        enable_monitoring_action.setChecked(self.profiler.enabled)
        enable_monitoring_action.toggled.connect(self._toggle_performance_monitoring)
        perf_menu.addAction(enable_monitoring_action)
        
        reset_stats_action = QAction("Reset Performance Statistics", self)
        reset_stats_action.triggered.connect(self._reset_performance_stats)
        perf_menu.addAction(reset_stats_action)
    
    @performance_monitor
    def _initialize_3d_scene(self):
        """Initialize 3D scene with performance monitoring."""
        # Create initial meshes
        self.initial_meshes = create_initial_meshes(resolution=self.config.MESH_RESOLUTION)
        
        # Set initial mesh
        self.current_mesh = self.initial_meshes[self.current_mesh_key].copy()
        
        # Create initial actor
        self.actor = self.plotter_widget.add_mesh(
            self.current_mesh,
            color=self.default_color,
            smooth_shading=True
        )
        
        # Set camera
        self.plotter_widget.camera_position = 'xy'
        self.plotter_widget.camera.zoom(1.2)
    
    def _setup_midi(self):
        """Setup MIDI handler."""
        if MIDI_AVAILABLE:
            self.midi_handler = MidiHandler()
            self.midi_handler.note_on_signal.connect(self._on_midi_note_on)
            self.midi_handler.note_off_signal.connect(self._on_midi_note_off)
            self.midi_handler.cc_signal.connect(self._on_midi_cc)
            
            if self.midi_handler.start(self.config.MIDI_PORT):
                print("MIDI handler started successfully")
            else:
                print("MIDI handler failed to start")
        else:
            print("MIDI not available")
    
    def _setup_audio(self):
        """Setup audio analyzer."""
        if AUDIO_AVAILABLE:
            self.audio_analyzer = AudioAnalyzer(self.config)
            print("Audio analyzer created (not started)")
        else:
            print("Audio not available")
    
    def _setup_scene_manager(self):
        """Setup scene manager for multi-object handling."""
        try:
            self.scene_manager = SceneManager(self.initial_meshes, self.plotter_widget)
            print("Scene manager initialized")
        except Exception as e:
            print(f"Scene manager initialization failed: {e}")
            self.scene_manager = None
    
    def _setup_performance_monitoring(self):
        """Setup performance monitoring connections."""
        self.profiler.fps_updated.connect(self._update_fps_status)
        self.profiler.memory_updated.connect(self._update_memory_status)
        self.profiler.performance_warning.connect(self._show_performance_warning)
    
    def _setup_timers(self):
        """Setup periodic timers."""
        # Cleanup timer
        self.cleanup_timer = QTimer()
        self.cleanup_timer.timeout.connect(self._cleanup_expired_elements)
        self.cleanup_timer.start(self.config.CLEANUP_INTERVAL * 1000)
        
        # Render timer for frame updates
        self.render_timer = QTimer()
        self.render_timer.timeout.connect(self._on_render_frame)
        self.render_timer.start(16)  # ~60 FPS
    
    @performance_monitor
    def _on_render_frame(self):
        """Handle render frame updates with performance monitoring."""
        self.profiler.start_frame()
        # Any per-frame processing would go here
        self.profiler.end_frame()
    
    @performance_monitor
    def _toggle_audio(self, enabled):
        """Toggle audio analysis with performance monitoring."""
        self.audio_enabled = enabled
        
        if enabled and self.audio_analyzer:
            # Give audio analyzer access to profiler
            self.audio_analyzer.profiler = self.profiler
            
            if self.audio_analyzer.start():
                self.audio_analyzer.onset_detected_signal.connect(self._on_audio_onset)
                self.audio_analyzer.amplitude_signal.connect(self._on_audio_amplitude)
                self.audio_label.setText("Audio: Active")
                print("Audio analysis enabled with performance monitoring")
            else:
                self.audio_enabled_check.setChecked(False)
                self.audio_label.setText("Audio: Failed to start")
        else:
            if self.audio_analyzer:
                self.audio_analyzer.stop()
            self.audio_label.setText("Audio: Disabled")
    
    @performance_monitor
    def _on_midi_note_on(self, note, velocity):
        """Handle MIDI note with scene manager."""
        try:
            if self.scene_manager:
                # Route to scene manager for multi-object handling
                affected_objects = self.scene_manager.handle_midi_note(note, velocity, True)
                
                if affected_objects:
                    print(f"Note ON: {note} -> Objects: {', '.join(affected_objects)}")
                    self._update_scene_display()
                else:
                    print(f"Note ON: {note} - No objects in range")
            else:
                # Fallback to single object mode
                self._handle_single_object_note_on(note, velocity)
                
        except Exception as e:
            print(f"Error handling note on: {e}")
    
    @performance_monitor
    def _on_midi_note_off(self, note):
        """Handle MIDI note off with scene manager."""
        try:
            if self.scene_manager:
                # Route to scene manager
                affected_objects = self.scene_manager.handle_midi_note(note, 0, False)
                
                if affected_objects:
                    print(f"Note OFF: {note} -> Objects: {', '.join(affected_objects)}")
                    self._update_scene_display()
            else:
                # Fallback to single object mode
                self._handle_single_object_note_off(note)
            
        except Exception as e:
            print(f"Error handling note off: {e}")
    
    def _handle_single_object_note_on(self, note, velocity):
        """Fallback single object note handling - FIXED with safe colors."""
        hue = note / 127.0
        # FIXED: Use safe HSV conversion instead of direct colorsys call
        rgb_color = safe_hsv_to_rgb(hue, 0.8, 1.0)
        
        self.active_notes[note] = {
            'color': rgb_color,
            'velocity': velocity,
            'timestamp': time.time()
        }
        
        self._update_main_object_color()
        self._update_displays()
    
    def _handle_single_object_note_off(self, note):
        """Fallback single object note off handling."""
        if note in self.active_notes:
            del self.active_notes[note]
        
        self._update_main_object_color()
        self._update_displays()
    
    def _update_scene_display(self):
        """Update the scene display information."""
        if self.scene_manager:
            summary = self.scene_manager.get_scene_summary()
            active_objects = summary['active_objects']
            total_notes = summary['total_active_notes']
            
            if total_notes > 0:
                note_info = []
                for obj_id, obj_info in summary['objects'].items():
                    if obj_info['active_notes'] > 0:
                        note_info.append(f"{obj_id}({obj_info['active_notes']})")
                
                self.notes_label.setText(f"Active: {', '.join(note_info)} | Total Notes: {total_notes}")
            else:
                self.notes_label.setText("Active Notes: None")
        else:
            self._update_displays()
    
    @performance_monitor
    def _on_midi_cc(self, cc_number, value):
        """Handle MIDI CC with performance monitoring."""
        if cc_number == 1:  # Mod wheel
            slider_value = int(value * 100)
            self.morph_slider.setValue(slider_value)
    
    @performance_monitor
    def _on_audio_onset(self, amplitude):
        """Handle audio onset with performance monitoring."""
        try:
            if not self.audio_enabled:
                return
                
            # Flash the main object white briefly
            self.audio_color_influence = min(amplitude * 3, 1.0)
            self._update_main_object_color()
            
            # Fade out flash
            QTimer.singleShot(150, self._fade_audio_influence)
            
        except Exception as e:
            print(f"Error handling audio onset: {e}")
    
    @performance_monitor
    def _on_audio_amplitude(self, amplitude):
        """Handle audio amplitude with performance monitoring."""
        try:
            if amplitude > 0.1:
                self.audio_morph_influence = min(amplitude * 0.2, 0.2)
                base_morph = self.morph_slider.value() / 100.0
                combined_morph = np.clip(base_morph + self.audio_morph_influence, 0, 1)
                self._apply_morphing(combined_morph)
            
            self.audio_label.setText(f"Audio: Amplitude {amplitude:.3f}")
            
        except Exception as e:
            print(f"Error handling audio amplitude: {e}")
    
    def _fade_audio_influence(self):
        """Fade out audio color influence."""
        self.audio_color_influence *= 0.5
        if self.audio_color_influence > 0.01:
            self._update_main_object_color()
            QTimer.singleShot(100, self._fade_audio_influence)
        else:
            self.audio_color_influence = 0.0
    
    @performance_monitor
    def _update_main_object_color(self):
        """Update main object color with performance monitoring and safe color handling."""
        try:
            # Calculate base color from MIDI notes
            if self.active_notes:
                if len(self.active_notes) == 1:
                    note_info = next(iter(self.active_notes.values()))
                    base_color = safe_color_array(note_info['color'])
                else:
                    # FIXED: Blend multiple MIDI notes safely
                    colors = [note_info['color'] for note_info in self.active_notes.values()]
                    weights = [note_info['velocity'] for note_info in self.active_notes.values()]
                    
                    base_color = blend_colors_safe(colors, weights)
            else:
                base_color = safe_color_array(self.default_color)
            
            # Apply audio flash if present
            if self.audio_color_influence > 0:
                flash_color = np.array([1.0, 1.0, 1.0])  # White flash
                influence = np.clip(self.audio_color_influence, 0.0, 1.0)
                final_color = (1 - influence) * base_color + influence * flash_color
                final_color = safe_color_array(final_color)  # FIXED: Ensure result is valid
            else:
                final_color = base_color
            
            # Update the single main object (fallback mode only)
            if hasattr(self, 'actor') and hasattr(self, 'current_mesh'):
                self.plotter_widget.remove_actor(self.actor)
                self.actor = self.plotter_widget.add_mesh(
                    self.current_mesh,
                    color=final_color,
                    smooth_shading=True
                )
                
                self.plotter_widget.render()
            
        except Exception as e:
            print(f"Error updating main object color: {e}")
    
    @performance_monitor
    def _apply_morphing(self, alpha):
        """Apply morphing with performance monitoring and safe color handling."""
        try:
            if self.scene_manager:
                # Apply morphing to all objects in the scene
                for obj_id, visual_obj in self.scene_manager.objects.items():
                    if hasattr(visual_obj, 'mesh') and hasattr(visual_obj, 'shape_type'):
                        # Get the current and target mesh keys
                        current_key = visual_obj.shape_type
                        target_key = getattr(visual_obj, 'current_morph_target', self.target_mesh_key)
                        
                        # Ensure both meshes exist
                        if current_key in self.initial_meshes and target_key in self.initial_meshes:
                            # Blend the meshes
                            blended_points = blend_meshes(
                                self.initial_meshes, 
                                current_key, 
                                target_key, 
                                alpha
                            )
                            
                            # Update the visual object's mesh
                            visual_obj.mesh.points = blended_points
                            
                            # Update morph amount for reference
                            visual_obj.morph_amount = alpha
                
                # Trigger scene rendering
                self.scene_manager.render_frame()
                
            elif hasattr(self, 'current_mesh') and hasattr(self, 'current_mesh_key'):
                # Fallback single object mode with safe color handling
                blended_points = blend_meshes(
                    self.initial_meshes, 
                    self.current_mesh_key, 
                    self.target_mesh_key, 
                    alpha
                )
                self.current_mesh.points = blended_points
                
                # Re-render the main object if actor exists
                if hasattr(self, 'actor'):
                    # FIXED: Get current color to preserve it - USE SAFE COLOR HANDLING
                    if self.active_notes:
                        # Calculate current color from active notes safely
                        if len(self.active_notes) == 1:
                            note_info = next(iter(self.active_notes.values()))
                            current_color = safe_color_array(note_info['color'])
                        else:
                            # FIXED: Blend multiple colors safely
                            colors = [note_info['color'] for note_info in self.active_notes.values()]
                            weights = [note_info['velocity'] for note_info in self.active_notes.values()]
                            current_color = blend_colors_safe(colors, weights)
                    else:
                        current_color = safe_color_array(self.default_color)
                    
                    # Remove old actor and add new one with morphed mesh
                    self.plotter_widget.remove_actor(self.actor)
                    self.actor = self.plotter_widget.add_mesh(
                        self.current_mesh,
                        color=current_color,
                        smooth_shading=True
                    )
                    
                    # Render the updated scene
                    self.plotter_widget.render()
            
        except Exception as e:
            print(f"Error applying morphing: {e}")
            import traceback
            traceback.print_exc()
    
    def _cleanup_expired_elements(self):
        """Clean up expired notes from scene manager."""
        if self.scene_manager:
            self.scene_manager.cleanup_expired_notes(60.0)
            self._update_scene_display()
        else:
            # Fallback cleanup for single object mode
            current_time = time.time()
            expired_notes = [note for note, info in self.active_notes.items() 
                            if current_time - info['timestamp'] > 60]
            
            for note in expired_notes:
                del self.active_notes[note]
            
            if expired_notes:
                self._update_main_object_color()
                self._update_displays()
    
    def _clear_all(self):
        """Clear all notes from scene manager."""
        if self.scene_manager:
            self.scene_manager.clear_all_notes()
            self._update_scene_display()
        else:
            # Fallback for single object mode
            self.active_notes.clear()
            self._update_main_object_color()
            self._update_displays()
    
    def _update_displays(self):
        """Update status displays."""
        if self.active_notes:
            note_names = [f"Note {note}" for note in sorted(self.active_notes.keys())]
            self.notes_label.setText(f"Active Notes: {', '.join(note_names)}")
        else:
            self.notes_label.setText("Active Notes: None")
    
    def _reconnect_midi(self):
        """Reconnect MIDI safely."""
        print("Reconnecting MIDI...")
        self.midi_handler.stop()
        
        # Give it a moment to cleanup
        QTimer.singleShot(100, self._do_midi_reconnect)
    
    def _do_midi_reconnect(self):
        """Perform the actual MIDI reconnection."""
        if self.midi_handler.start(self.config.MIDI_PORT):
            self.status_bar.showMessage("MIDI reconnected successfully", 3000)
            print("MIDI reconnected successfully")
        else:
            self.status_bar.showMessage("MIDI reconnection failed", 3000)
            print("MIDI reconnection failed")
    
    @performance_monitor
    def on_morph_slider_change(self, value):
        """Handle morph slider - affects all objects in scene."""
        alpha = value / 100.0
        
        if self.scene_manager:
            # Apply morphing to all objects that support it
            for obj_id, visual_obj in self.scene_manager.objects.items():
                if hasattr(visual_obj, 'morph_amount'):
                    visual_obj.morph_amount = alpha
            
            # Trigger scene update
            self.scene_manager.render_frame()
        else:
            # Fallback single object morphing
            self._apply_morphing(alpha)
            self._update_main_object_color()
    
    def on_target_shape_change(self, target_key):
        """Handle target shape change."""
        if target_key in self.initial_meshes:
            self.target_mesh_key = target_key
            
            if self.scene_manager:
                # Set target shape for all objects
                for visual_obj in self.scene_manager.objects.values():
                    visual_obj.current_morph_target = target_key
                
                # Apply current morph amount
                self.on_morph_slider_change(self.morph_slider.value())
            else:
                # Fallback single object
                self.on_morph_slider_change(self.morph_slider.value())
    
    # Configuration dialog methods
    def _show_config_dialog(self):
        """Show configuration dialog."""
        if self.config_dialog is None:
            self.config_dialog = ConfigurationDialog(self.config, self)
            self.config_dialog.settings_changed.connect(self._on_settings_changed)
        
        self.config_dialog.show()
        self.config_dialog.raise_()
        self.config_dialog.activateWindow()
    
    def _on_settings_changed(self):
        """Handle settings changes from configuration dialog."""
        print("Settings changed - reloading configuration")
        self.config.load_settings()
        
        # Restart systems that depend on config
        if self.audio_enabled and self.audio_analyzer:
            self.audio_analyzer.stop()
            if self.audio_analyzer.start():
                print("Audio restarted with new settings")
        
        self.status_bar.showMessage("Settings applied", 2000)
    
    def _show_scene_config_dialog(self):
        """Show scene configuration dialog."""
        if self.scene_config_dialog is None:
            self.scene_config_dialog = SceneConfigurationDialog(self.scene_manager, self)
        
        self.scene_config_dialog.show()
        self.scene_config_dialog.raise_()
        self.scene_config_dialog.activateWindow()
    
    def _show_performance_dialog(self):
        """Show performance monitoring dialog."""
        if self.performance_dialog is None:
            self.performance_dialog = PerformanceDialog(self.profiler, self)
        
        self.performance_dialog.show()
        self.performance_dialog.raise_()
        self.performance_dialog.activateWindow()
    
    def _toggle_performance_monitoring(self, enabled):
        """Toggle performance monitoring."""
        if enabled:
            self.profiler.start_monitoring()
        else:
            self.profiler.stop_monitoring()
    
    def _reset_performance_stats(self):
        """Reset performance statistics."""
        self.profiler.reset_stats()
        self.status_bar.showMessage("Performance statistics reset", 2000)
    
    def _export_performance_data(self):
        """Export performance data to file."""
        try:
            filename = f"performance_data_{int(time.time())}.json"
            self.profiler.export_data(filename)
            self.status_bar.showMessage(f"Performance data exported to {filename}", 3000)
        except Exception as e:
            QMessageBox.warning(self, "Export Error", f"Failed to export performance data: {e}")
    
    def _load_settings(self):
        """Load application settings."""
        settings = QSettings()
        
        # Window geometry
        geometry = settings.value("geometry")
        if geometry:
            self.restoreGeometry(geometry)
        
        # Audio enabled state
        audio_enabled = settings.value("audio_enabled", False, bool)
        self.audio_enabled_check.setChecked(audio_enabled)
        
        # Target shape
        target_shape = settings.value("target_shape", "cube")
        if target_shape in ["sphere", "cube", "cone", "icosahedron", "torus"]:
            self.target_combo.setCurrentText(target_shape)
            self.target_mesh_key = target_shape
        
        # Morph amount
        morph_amount = settings.value("morph_amount", 0, int)
        self.morph_slider.setValue(morph_amount)
    
    def _save_settings(self):
        """Save application settings."""
        settings = QSettings()
        
        # Window geometry
        settings.setValue("geometry", self.saveGeometry())
        
        # Audio enabled state
        settings.setValue("audio_enabled", self.audio_enabled_check.isChecked())
        
        # Target shape
        settings.setValue("target_shape", self.target_combo.currentText())
        
        # Morph amount
        settings.setValue("morph_amount", self.morph_slider.value())
    
    def _update_fps_status(self, fps):
        """Update FPS display in status bar."""
        color = "green" if fps >= 30 else "orange" if fps >= 20 else "red"
        self.fps_label.setText(f"<font color='{color}'>FPS: {fps:.1f}</font>")
    
    def _update_memory_status(self, memory_mb, memory_percent):
        """Update memory usage in status bar."""
        color = "green" if memory_percent < 70 else "orange" if memory_percent < 85 else "red"
        self.memory_label.setText(f"<font color='{color}'>Mem: {memory_percent:.1f}%</font>")
    
    def _show_performance_warning(self, warning):
        """Show performance warning in status bar."""
        self.status_bar.showMessage(f"⚠️ {warning}", 5000)  # Show for 5 seconds
    
    def closeEvent(self, event):
        """Clean shutdown with performance monitoring cleanup."""
        print("Shutting down application...")
        
        # Save settings
        self._save_settings()
        
        # Stop all systems gracefully
        try:
            if self.midi_handler:
                print("Stopping MIDI handler...")
                self.midi_handler.stop()
        except Exception as e:
            print(f"Error stopping MIDI handler: {e}")
        
        try:
            if self.audio_analyzer:
                print("Stopping audio analyzer...")
                self.audio_analyzer.stop()
        except Exception as e:
            print(f"Error stopping audio analyzer: {e}")
        
        try:
            # Stop performance monitoring
            print("Stopping performance monitoring...")
            self.profiler.stop_monitoring()
        except Exception as e:
            print(f"Error stopping performance monitoring: {e}")
        
        try:
            # Stop timers
            self.cleanup_timer.stop()
            self.render_timer.stop()
        except Exception as e:
            print(f"Error stopping timers: {e}")
        
        try:
            # Close dialogs if open
            if self.performance_dialog:
                self.performance_dialog.close()
            
            if self.config_dialog:
                self.config_dialog.close()
            
            if self.scene_config_dialog:
                self.scene_config_dialog.close()
        except Exception as e:
            print(f"Error closing dialogs: {e}")
        
        print("Application shutdown complete")
        event.accept()

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    app = QApplication(sys.argv)
    
    window = PerformanceAwareMainWindow()
    window.resize(1000, 700)
    window.show()
    
    sys.exit(app.exec())

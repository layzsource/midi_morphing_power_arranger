<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Signal→Form: Live Eigenmode Cube</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0c10; color:#eaeaea; font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial; }
    #hud { position:fixed; top:12px; left:12px; background:rgba(0,0,0,0.45); padding:10px 12px; border-radius:12px; }
    #hud .row{ display:flex; gap:8px; align-items:center; margin:4px 0; }
    #hud label{ font-size:12px; width:86px; color:#b8c6d1; }
    #hud input[type=range]{ width:200px; }
    #hud .pill { padding:2px 8px; border-radius:999px; background:#1f2937; font-size:11px; }
    a { color:#93c5fd; }
  </style>
</head>
<body>
<div id="hud">
  <div class="row"><span class="pill">PMW</span><input id="pmw" type="range" min="0" max="1" step="0.001" value="0.5"><span id="pmwVal">0.50</span></div>
  <div class="row"><label>φ₀ breathing</label><input id="w0" type="range" min="0" max="1" step="0.001" value="0.2"><span id="w0Val">0.20</span></div>
  <div class="row"><label>φ₁ twisting</label><input id="w1" type="range" min="0" max="1" step="0.001" value="0.4"><span id="w1Val">0.40</span></div>
  <div class="row"><label>φ₂ bending</label><input id="w2" type="range" min="0" max="1" step="0.001" value="0.3"><span id="w2Val">0.30</span></div>
  <div class="row"><label>φ₃ rippling</label><input id="w3" type="range" min="0" max="1" step="0.001" value="0.2"><span id="w3Val">0.20</span></div>
  <div class="row" style="margin-top:6px;"><span class="pill" id="status">demo: internal synth</span></div>
  <div class="row" style="font-size:12px; color:#9ba7b4; max-width:520px;">
    Tip: send live frames via <code>window.postMessage({type:'SFE_FRAME', c:[...]})</code>,
    or connect to <code>ws://localhost:7070</code> (see script).
  </div>
</div>
<canvas id="c"></canvas>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0c10);

const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 200);
camera.position.set(2.1, 1.7, 3.8);

const light = new THREE.DirectionalLight(0xffffff, 2.0);
light.position.set(3, 4, 2);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.55));

function makeCubePanels(n=24, size=1.6) {
  const group = new THREE.Group();
  const half = size/2;
  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.35,
    metalness: 0.1,
    side: THREE.DoubleSide,
    onBeforeCompile: (shader)=>{
      shader.uniforms.uRGB = { value: new THREE.Vector3(1,1,1) };
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <dithering_fragment>',
        `#include <dithering_fragment>
         gl_FragColor.rgb *= uRGB;`
      );
      group.userData.shader = shader;
    }
  });

  const faces = [];
  const dirs = [
    { n:[ 1, 0, 0], u:[0, 1, 0], v:[0, 0,-1], p:[ half, 0, 0] },
    { n:[-1, 0, 0], u:[0, 1, 0], v:[0, 0, 1], p:[-half, 0, 0] },
    { n:[ 0, 1, 0], u:[1, 0, 0], v:[0, 0, 1], p:[ 0, half,0] },
    { n:[ 0,-1, 0], u:[1, 0, 0], v:[0, 0,-1], p:[ 0,-half,0] },
    { n:[ 0, 0, 1], u:[1, 0, 0], v:[0, 1, 0], p:[ 0, 0, half] },
    { n:[ 0, 0,-1], u:[1, 0, 0], v:[0,-1, 0], p:[ 0, 0,-half]}
  ];

  for (const d of dirs) {
    const geo = new THREE.PlaneGeometry(size, size, n, n);
    const U = new THREE.Vector3(...d.u);
    const V = new THREE.Vector3(...d.v);
    const P = new THREE.Vector3(...d.p);
    const pos = geo.getAttribute('position');
    const base = new Float32Array(pos.array.length);
    for (let i=0; i<pos.count; i++) {
      const x = pos.getX(i), y = pos.getY(i);
      const world = new THREE.Vector3().addScaledVector(U, x).addScaledVector(V, y).add(P);
      base[i*3+0]=world.x; base[i*3+1]=world.y; base[i*3+2]=world.z;
      pos.setXYZ(i, world.x, world.y, world.z);
    }
    geo.setAttribute('base', new THREE.BufferAttribute(base, 3));
    const mesh = new THREE.Mesh(geo, mat);
    faces.push(mesh);
    group.add(mesh);
  }
  return group;
}

const cube = makeCubePanels(24, 1.8);
scene.add(cube);

function basisFuncs(p) {
  const r = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
  const a = Math.atan2(p.y, p.x);
  const h = p.y;

  const phi0 = 0.6*Math.sin(2.0*r);                // breathing
  const phi1 = 0.5*Math.sin(3.0*a);                // twisting
  const phi2 = 0.4*(h*h - 0.3);                    // bending
  const phi3 = 0.18*Math.sin(8.0*p.x)*Math.cos(8.0*p.z); // rippling
  return [phi0,phi1,phi2,phi3];
}

let coeffs = [0.2,0.4,0.3,0.2];
let pmw = 0.5;

function setPMW(v){
  pmw = Math.min(1,Math.max(0,v));
  const S = pmw;
  const shader = cube.userData.shader;
  if (shader) shader.uniforms.uRGB.value.setScalar(0.5 + 0.5*S);
}

const pmwEl = document.getElementById('pmw');
const wEls = [document.getElementById('w0'),document.getElementById('w1'),document.getElementById('w2'),document.getElementById('w3')];
const pv = (id,v)=>document.getElementById(id).textContent = Number(v).toFixed(2);
pmwEl.addEventListener('input', e=>{ setPMW(parseFloat(e.target.value)); pv('pmwVal', e.target.value); });
wEls.forEach((el,idx)=> el.addEventListener('input', e=>{ coeffs[idx]=parseFloat(e.target.value); pv('w'+idx+'Val', e.target.value); }));
['pmwVal','w0Val','w1Val','w2Val','w3Val'].forEach((id,i)=> pv(id, i? wEls[i-1].value : pmwEl.value));
setPMW(parseFloat(pmwEl.value));

window.addEventListener('message', (ev)=>{
  const d = ev.data;
  if (d && d.type === 'SFE_FRAME' && Array.isArray(d.c)) {
    coeffs = d.c.slice(0,4);
    if (typeof d.pmw === 'number') setPMW(d.pmw);
    document.getElementById('status').textContent = 'live: postMessage';
  }
});

(function tryWS(){
  const url = 'ws://localhost:7070';
  try {
    const ws = new WebSocket(url);
    ws.onopen = ()=>{ document.getElementById('status').textContent = 'live: ' + url; };
    ws.onmessage = (ev)=>{
      try {
        const obj = JSON.parse(ev.data);
        if (Array.isArray(obj.c)) coeffs = obj.c.slice(0,4);
        if (typeof obj.pmw === 'number') setPMW(obj.pmw);
      } catch(e){}
    };
    ws.onerror = ()=>{};
  } catch(e){}
})();

function resizeRendererToDisplaySize() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  const needResize = (renderer.domElement.width !== width || renderer.domElement.height !== height);
  if (needResize) {
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  }
}
window.addEventListener('resize', resizeRendererToDisplaySize);

const tmp = new THREE.Vector3();
function animate(t){
  resizeRendererToDisplaySize();
  const time = t*0.001;
  scene.rotation.y = time*0.22;

  for (const face of cube.children) {
    const pos = face.geometry.getAttribute('position');
    const base = face.geometry.getAttribute('base');
    for (let i=0; i<pos.count; i++) {
      const bx = base.getX(i), by = base.getY(i), bz = base.getZ(i);
      const p = {x:bx, y:by, z:bz};
      const [f0,f1,f2,f3] = basisFuncs(p);
      const d = coeffs[0]*f0 + coeffs[1]*f1 + coeffs[2]*f2 + coeffs[3]*f3;
      const len = Math.hypot(bx,by,bz) || 1.0;
      const ux = bx/len, uy = by/len, uz = bz/len;
      pos.setXYZ(i, bx + d*ux, by + d*uy, bz + d*uz);
    }
    pos.needsUpdate = true;
    face.geometry.computeVertexNormals();
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Signalâ†’Form: Spherical POV Microfiche</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #eaeaea;
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial;
    }

    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      background: rgba(0,0,0,0.7);
      padding: 12px 16px;
      border-radius: 16px;
      min-width: 320px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.1);
    }

    #hud .row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin: 6px 0;
    }

    #hud .title {
      font-size: 14px;
      font-weight: 600;
      color: #93c5fd;
      margin-bottom: 8px;
    }

    #hud .param {
      font-size: 12px;
      width: 100px;
      color: #b8c6d1;
    }

    #hud input[type=range] {
      width: 160px;
      height: 4px;
      background: #1f2937;
      border-radius: 2px;
      outline: none;
    }

    #hud input[type=range]::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #60a5fa;
      cursor: pointer;
    }

    #hud .value {
      font-size: 11px;
      color: #9ca3af;
      min-width: 40px;
      text-align: right;
    }

    #hud .status {
      padding: 4px 12px;
      border-radius: 12px;
      background: #1f2937;
      font-size: 11px;
      color: #34d399;
    }

    #hud .meters {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    #hud .meter {
      flex: 1;
      height: 24px;
      background: #1f2937;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }

    #hud .meter .fill {
      height: 100%;
      transition: width 0.1s ease;
      border-radius: 4px;
    }

    #hud .meter.unity .fill { background: #10b981; }
    #hud .meter.entropy .fill { background: #3b82f6; }
    #hud .meter.temporal .fill { background: #ef4444; }

    #hud .meter .label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10px;
      color: #fff;
      mix-blend-mode: difference;
      font-weight: 500;
    }

    .controls-help {
      position: fixed;
      bottom: 12px;
      left: 12px;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 11px;
      color: #9ca3af;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.1);
    }

    #center-me {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: rgba(239, 68, 68, 0.9);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 24px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      backdrop-filter: blur(8px);
      transition: all 0.2s ease;
    }

    #center-me:hover {
      background: rgba(239, 68, 68, 1);
      transform: scale(1.05);
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .sprite-card {
      position: absolute;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 11px;
      pointer-events: none;
      max-width: 200px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.2);
      z-index: 1000;
    }

    .sprite-card .id {
      font-weight: 600;
      color: #60a5fa;
      margin-bottom: 4px;
    }

    .sprite-card .palette {
      display: flex;
      gap: 2px;
      margin-top: 4px;
    }

    .sprite-card .color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    /* MIDI Activity Feedback */
    .midi-activity {
      position: fixed;
      top: 20px;
      right: 350px;
      background: rgba(59, 130, 246, 0.9);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      opacity: 0;
      transform: translateY(-10px);
      transition: all 0.3s ease;
      z-index: 1001;
      backdrop-filter: blur(8px);
    }

    .midi-activity.show {
      opacity: 1;
      transform: translateY(0);
    }

    .preset-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(16, 185, 129, 0.95);
      color: white;
      padding: 20px 30px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      opacity: 0;
      scale: 0.8;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 2000;
      backdrop-filter: blur(12px);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .preset-notification.show {
      opacity: 1;
      scale: 1;
    }

    .midi-indicator {
      display: inline-block;
      width: 6px;
      height: 6px;
      background: #ef4444;
      border-radius: 50%;
      margin-left: 4px;
      opacity: 0;
      animation: midiFlash 0.2s ease-out;
    }

    @keyframes midiFlash {
      0% { opacity: 0; scale: 0.5; }
      50% { opacity: 1; scale: 1.5; background: #10b981; }
      100% { opacity: 0; scale: 1; }
    }
  </style>
</head>
<body>

<!-- HUD Controls -->
<div id="hud">
  <div class="title">Signalâ†’Form Spherical POV</div>

  <div class="row">
    <span class="param">Zoom (Î¶)</span>
    <input id="zeta" type="range" min="0" max="1" step="0.001" value="0.0">
    <span id="zeta-val" class="value">0.000</span>
  </div>

  <div class="row">
    <span class="param">PMW</span>
    <input id="pmw" type="range" min="0" max="1" step="0.001" value="0.5">
    <span id="pmw-val" class="value">0.500</span>
  </div>

  <div class="row">
    <span class="param">Unity (U)</span>
    <input id="unity" type="range" min="0" max="1" step="0.001" value="0.5">
    <span id="unity-val" class="value">0.500</span>
  </div>

  <div class="row">
    <span class="param">Flatness (F)</span>
    <input id="flatness" type="range" min="0" max="1" step="0.001" value="0.5">
    <span id="flatness-val" class="value">0.500</span>
  </div>

  <!-- Telemetry Meters -->
  <div class="meters">
    <div class="meter unity">
      <div class="fill" id="unity-meter" style="width: 50%"></div>
      <div class="label">U</div>
    </div>
    <div class="meter entropy">
      <div class="fill" id="entropy-meter" style="width: 40%"></div>
      <div class="label">E</div>
    </div>
    <div class="meter temporal">
      <div class="fill" id="temporal-meter" style="width: 20%"></div>
      <div class="label">R</div>
    </div>
  </div>

  <div class="row">
    <span id="ws-status" class="status">Connecting...</span>
  </div>
  <div class="row">
    <span id="midi-status" class="status" style="color: #f59e0b;">MIDI: Disconnected</span>
    <span class="midi-indicator" id="midi-indicator"></span>
  </div>
  <div class="row">
    <span id="multiwindow-status" class="status" style="color: #38bdf8;">Multi-Window: Active</span>
  </div>
</div>

<!-- Controls Help -->
<div class="controls-help">
  <div><strong>Mouse:</strong> Orbit â€¢ <strong>Wheel:</strong> Zoom Î¶ â€¢ <strong>Click sprite:</strong> Portal</div>
  <div><strong>Outsideâ†’Inside:</strong> Universe â†’ Surface â†’ Center POV</div>
</div>

<!-- Center Me Button -->
<button id="center-me">CENTER ME</button>

<!-- Sprite Info Card -->
<div id="sprite-card" class="sprite-card" style="display: none;">
  <div class="id"></div>
  <div class="type"></div>
  <div class="palette"></div>
</div>

<!-- Main Canvas -->
<canvas id="canvas"></canvas>

<!-- MIDI Activity Feedback -->
<div id="midi-activity" class="midi-activity"></div>

<!-- Preset Notification -->
<div id="preset-notification" class="preset-notification"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

// Configuration from microfiche_config.json
const config = {
  ws_telemetry: "ws://localhost:7070/telemetry",
  http_control: "http://localhost:7070/control",
  encoder_base: "http://localhost:7071",
  collection_id: "home_cube",
  shells: {
    radii: [8.0, 4.0, 2.0],
    membrane_enter: 0.45,
    membrane_exit: 0.70,
    center_view: 0.80
  }
};

// Three.js setup
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, 2, 0.1, 100);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
directionalLight.position.set(10, 10, 5);
scene.add(directionalLight);

// State
let zeta = 0.0; // Outsideâ†’inside parameter [0,1]
let pmw = 0.5;
let collection = null;
let sprites = [];
let shells = [];
let instrumentMesh = null;
let ws = null;
let midiWS = null;
let telemetryData = {};
let midiMapping = {}; // CC number -> parameter name mapping
let midiPanelConfig = {}; // Extended MIDI panel configuration
let midiConfigLastModified = null; // Track config file changes for hot-reload
let presets = {}; // Preset configurations
let midiActivity = {}; // Track recent MIDI activity for visual feedback

// Multi-window synchronization
let broadcastChannel = null;
let isWindowActive = true;
let windowId = Math.random().toString(36).substring(2, 9);
let connectedWindows = new Set([windowId]);
let lastSyncTime = 0;

// Î¶-Camera system
function updateCamera() {
  const radii = config.shells.radii;
  const R_out = radii[0]; // 8.0
  const R_in = 0.01;

  // Smooth transition with membrane easing
  const membrane_t = smoothstep(config.shells.membrane_enter, config.shells.membrane_exit, zeta);
  const r = lerp(R_out, R_in, zeta);

  // Position camera along radius
  const theta = Date.now() * 0.0003; // Subtle rotation
  const x = r * Math.cos(theta);
  const z = r * Math.sin(theta);
  camera.position.set(x, 0, z);

  // Look at center
  camera.lookAt(0, 0, 0);

  // Up vector slerp for smooth membrane crossing
  const upOuter = new THREE.Vector3(0, 1, 0);
  const upInner = new THREE.Vector3(0, -1, 0);
  const up = upOuter.clone().lerp(upInner, zeta).normalize();
  camera.up.copy(up);

  // Adjust FOV for inside view
  camera.fov = lerp(60, 90, smoothstep(0.7, 1.0, zeta));
  camera.updateProjectionMatrix();
}

// Utility functions
function lerp(a, b, t) { return a + (b - a) * t; }
function smoothstep(edge0, edge1, x) {
  const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
  return t * t * (3 - 2 * t);
}

// Create spherical shells
function createShells() {
  const radii = config.shells.radii; // [8.0, 4.0, 2.0]

  radii.forEach((radius, i) => {
    const geometry = new THREE.SphereGeometry(radius, 32, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0x333333,
      wireframe: true,
      transparent: true,
      opacity: 0.1,
      side: zeta > 0.75 ? THREE.BackSide : THREE.FrontSide
    });

    const shell = new THREE.Mesh(geometry, material);
    shell.userData = { radius, index: i };
    shells.push(shell);
    scene.add(shell);
  });
}

// Create instrument at center (cubeâ†’sphere morph)
function createInstrument() {
  const geometry = new THREE.BoxGeometry(1, 1, 1, 4, 4, 4);
  const material = new THREE.MeshLambertMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.8,
    side: THREE.DoubleSide
  });

  instrumentMesh = new THREE.Mesh(geometry, material);
  scene.add(instrumentMesh);
}

// Create sprite billboards on shells
function createSprites() {
  if (!collection) return;

  const outerRadius = config.shells.radii[0]; // 8.0
  const spriteGeometry = new THREE.PlaneGeometry(0.3, 0.3);

  collection.media.forEach((media, i) => {
    // Distribute sprites on outer shell using spherical coordinates
    const phi = (i / collection.media.length) * Math.PI * 2;
    const theta = Math.acos(1 - 2 * (i * 0.618034) % 1); // Golden ratio distribution

    const x = outerRadius * Math.sin(theta) * Math.cos(phi);
    const y = outerRadius * Math.cos(theta);
    const z = outerRadius * Math.sin(theta) * Math.sin(phi);

    // Create sprite material with color from palette
    const color = new THREE.Color().setRGB(
      media.palette[0],
      media.palette[1],
      media.palette[2]
    );

    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    const sprite = new THREE.Mesh(spriteGeometry, material);
    sprite.position.set(x, y, z);
    sprite.lookAt(0, 0, 0); // Face center
    sprite.userData = { media, id: media.id };

    sprites.push(sprite);
    scene.add(sprite);
  });
}

// Update shell rendering based on Î¶
function updateShells() {
  shells.forEach(shell => {
    const inside = zeta > 0.75;
    shell.material.side = inside ? THREE.BackSide : THREE.FrontSide;
    shell.material.opacity = lerp(0.1, 0.05, zeta);
  });
}

// Morphing instrument (cubeâ†’sphere)
function updateInstrument() {
  if (!instrumentMesh) return;

  const morphProgress = smoothstep(config.shells.membrane_enter, config.shells.membrane_exit, zeta);
  const geometry = instrumentMesh.geometry;
  const positions = geometry.attributes.position;

  // Store original positions
  if (!geometry.userData.originalPositions) {
    geometry.userData.originalPositions = new Float32Array(positions.array);
  }

  const original = geometry.userData.originalPositions;

  // Morph vertices cubeâ†’sphere
  for (let i = 0; i < positions.count; i++) {
    const x = original[i * 3];
    const y = original[i * 3 + 1];
    const z = original[i * 3 + 2];

    // Calculate sphere position
    const length = Math.sqrt(x*x + y*y + z*z);
    const sphereRadius = 0.7;

    if (length > 0) {
      const sphereX = (x / length) * sphereRadius;
      const sphereY = (y / length) * sphereRadius;
      const sphereZ = (z / length) * sphereRadius;

      // Interpolate cubeâ†’sphere
      positions.setXYZ(i,
        lerp(x, sphereX, morphProgress),
        lerp(y, sphereY, morphProgress),
        lerp(z, sphereZ, morphProgress)
      );
    }
  }

  positions.needsUpdate = true;
  geometry.computeVertexNormals();

  // Apply modal coefficients if available
  if (telemetryData.c && telemetryData.c.length >= 4) {
    // Simple deformation based on spectral coefficients
    for (let i = 0; i < positions.count; i++) {
      const x = positions.getX(i);
      const y = positions.getY(i);
      const z = positions.getZ(i);

      const r = Math.sqrt(x*x + y*y + z*z);
      const theta = Math.atan2(y, x);
      const phi = Math.acos(z / (r || 1));

      // Apply eigenmode deformation
      let displacement = 0;
      displacement += telemetryData.c[0] * 0.1 * Math.sin(2 * r);
      displacement += telemetryData.c[1] * 0.1 * Math.sin(3 * theta);
      displacement += telemetryData.c[2] * 0.1 * (y*y - 0.3);
      displacement += telemetryData.c[3] * 0.05 * Math.sin(8 * x) * Math.cos(8 * z);

      const normal = new THREE.Vector3(x, y, z).normalize();
      positions.setXYZ(i,
        x + normal.x * displacement,
        y + normal.y * displacement,
        z + normal.z * displacement
      );
    }
    positions.needsUpdate = true;
  }

  // Update material based on PMW
  const tint = 0.5 + 0.5 * pmw;
  instrumentMesh.material.color.setRGB(tint, tint, tint);
}

// WebSocket connection
function connectWebSocket() {
  try {
    ws = new WebSocket(config.ws_telemetry);

    ws.onopen = () => {
      document.getElementById('ws-status').textContent = 'Connected';
      document.getElementById('ws-status').style.color = '#34d399';
    };

    ws.onmessage = (event) => {
      try {
        telemetryData = JSON.parse(event.data);
        updateTelemetryDisplay();
      } catch (e) {
        console.warn('Invalid telemetry data:', e);
      }
    };

    ws.onerror = () => {
      document.getElementById('ws-status').textContent = 'Error';
      document.getElementById('ws-status').style.color = '#ef4444';
    };

    ws.onclose = () => {
      document.getElementById('ws-status').textContent = 'Disconnected';
      document.getElementById('ws-status').style.color = '#f59e0b';
      // Reconnect after delay
      setTimeout(connectWebSocket, 2000);
    };
  } catch (e) {
    console.error('WebSocket connection failed:', e);
    document.getElementById('ws-status').textContent = 'Failed';
    document.getElementById('ws-status').style.color = '#ef4444';
  }
}

// Update telemetry display
function updateTelemetryDisplay() {
  if (!telemetryData) return;

  // Update meters
  if (telemetryData.S) {
    const unity = telemetryData.S.U || 0;
    document.getElementById('unity-meter').style.width = `${unity * 100}%`;
  }

  if (typeof telemetryData.entropy === 'number') {
    document.getElementById('entropy-meter').style.width = `${telemetryData.entropy * 100}%`;
  }

  if (typeof telemetryData.R === 'number') {
    document.getElementById('temporal-meter').style.width = `${Math.min(telemetryData.R * 100, 100)}%`;
  }

  // Update PMW if provided
  if (typeof telemetryData.pmw === 'number') {
    pmw = telemetryData.pmw;
    document.getElementById('pmw').value = pmw;
    document.getElementById('pmw-val').textContent = pmw.toFixed(3);
  }
}

// Portal system (sprite click â†’ control)
async function handleSpriteClick(sprite) {
  const mediaId = sprite.userData.media.id;
  console.log('Portal clicked:', mediaId);

  // Broadcast sprite interaction to other windows
  broadcastUpdate('sprite_interaction', {
    mediaId: mediaId,
    type: 'portal_click'
  });

  try {
    // Get stimulus from encoder
    const stimResponse = await fetch(`${config.encoder_base}/stim/${encodeURIComponent(mediaId)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });

    const stimulus = await stimResponse.json();
    console.log('Stimulus:', stimulus);

    // Send control to engine
    const controlResponse = await fetch(config.http_control, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        set: { pmw: stimulus.pmw_hint || pmw },
        pulse: stimulus.pulse || { k: 5, amp: 0.6, decay: 0.92 },
        bias: stimulus.bias_modes ? { weights: stimulus.bias_modes } : undefined
      })
    });

    console.log('Control sent, status:', controlResponse.status);

    // Visual feedback
    sprite.material.emissive.setHex(0xff4444);
    setTimeout(() => {
      sprite.material.emissive.setHex(0x000000);
    }, 200);

  } catch (error) {
    console.error('Portal error:', error);
  }
}

// Load MIDI mapping configuration
async function loadMidiMapping() {
  try {
    // Try to load extended panel config first
    const panelResponse = await fetch('./midi_panels.json?t=' + Date.now());
    if (panelResponse.ok) {
      midiPanelConfig = await panelResponse.json();
      midiMapping = midiPanelConfig.cc_mappings || {};
      presets = midiPanelConfig.presets || {};
      console.log('ðŸŽ›ï¸ Extended MIDI panel config loaded:', midiPanelConfig);
      return;
    }

    // Fallback to simple mapping file
    const response = await fetch('./midi_map.json?t=' + Date.now());
    if (response.ok) {
      const lastModified = response.headers.get('Last-Modified');

      // Check if config has changed
      if (midiConfigLastModified && lastModified && lastModified === midiConfigLastModified) {
        return; // No changes, skip reload
      }

      midiMapping = await response.json();
      midiConfigLastModified = lastModified;
      console.log('MIDI mapping loaded:', midiMapping);
    } else {
      console.warn('Could not load MIDI config files, using defaults');
      setDefaultMidiConfig();
    }
  } catch (error) {
    console.error('Failed to load MIDI mapping:', error);
    setDefaultMidiConfig();
  }
}

// Set default MIDI configuration
function setDefaultMidiConfig() {
  midiMapping = {
    "1": "zeta",
    "2": "pmw",
    "3": "unity",
    "4": "flatness"
  };
  presets = {
    "preset_outside": { name: "Outside", zeta: 0.0, pmw: 0.3, unity: 0.5, flatness: 0.4 },
    "preset_center": { name: "Center", zeta: 1.0, pmw: 0.9, unity: 0.8, flatness: 0.9 }
  };
}

// Periodically check for MIDI config changes
function startMidiConfigWatcher() {
  setInterval(async () => {
    await loadMidiMapping();
  }, 5000); // Check every 5 seconds
}

// Scale MIDI CC value (0-127) to parameter range (0.0-1.0)
function scaleMidiValue(ccValue) {
  return Math.max(0, Math.min(1, ccValue / 127.0));
}

// Update parameter based on MIDI mapping
function updateParameterFromMidi(paramName, value) {
  const scaledValue = scaleMidiValue(value);

  // Track MIDI activity for visual feedback
  midiActivity[paramName] = { value: scaledValue, timestamp: Date.now() };
  showMidiActivity(paramName, scaledValue);

  switch (paramName) {
    case 'zeta':
      zeta = scaledValue;
      document.getElementById('zeta').value = zeta;
      document.getElementById('zeta-val').textContent = zeta.toFixed(3);
      updateCamera();
      updateShells();
      break;

    case 'pmw':
      pmw = scaledValue;
      document.getElementById('pmw').value = pmw;
      document.getElementById('pmw-val').textContent = pmw.toFixed(3);
      sendControl({ set: { pmw: pmw } });
      break;

    case 'unity':
      document.getElementById('unity').value = scaledValue;
      document.getElementById('unity-val').textContent = scaledValue.toFixed(3);
      sendControl({ set: { unity: scaledValue } });
      break;

    case 'flatness':
      document.getElementById('flatness').value = scaledValue;
      document.getElementById('flatness-val').textContent = scaledValue.toFixed(3);
      sendControl({ set: { flatness: scaledValue } });
      break;

    // Extended parameters
    case 'shell_opacity':
      updateShellOpacity(scaledValue);
      break;

    case 'instrument_scale':
      updateInstrumentScale(scaledValue);
      break;

    case 'deform_intensity':
      updateDeformIntensity(scaledValue);
      break;

    default:
      console.warn(`Unknown parameter: ${paramName}`);
  }
}

// Apply preset configuration
function applyPreset(presetName) {
  const preset = presets[presetName];
  if (!preset) {
    console.warn(`Preset not found: ${presetName}`);
    return;
  }

  console.log(`ðŸŽ¹ Applying preset: ${preset.name}`);

  // Animate to preset values
  if (typeof preset.zeta === 'number') {
    animateParameterTo('zeta', preset.zeta);
  }
  if (typeof preset.pmw === 'number') {
    animateParameterTo('pmw', preset.pmw);
  }
  if (typeof preset.unity === 'number') {
    animateParameterTo('unity', preset.unity);
  }
  if (typeof preset.flatness === 'number') {
    animateParameterTo('flatness', preset.flatness);
  }

  // Visual feedback
  showPresetNotification(preset.name);
}

// Save current state as preset
function saveCurrentStateAsPreset(name) {
  const currentState = {
    name: name,
    zeta: zeta,
    pmw: pmw,
    unity: parseFloat(document.getElementById('unity').value),
    flatness: parseFloat(document.getElementById('flatness').value),
    timestamp: Date.now()
  };

  // Store in localStorage for persistence
  const savedPresets = JSON.parse(localStorage.getItem('userPresets') || '{}');
  savedPresets[`user_${name.toLowerCase().replace(/\s+/g, '_')}`] = currentState;
  localStorage.setItem('userPresets', JSON.stringify(savedPresets));

  console.log(`ðŸ’¾ Saved preset: ${name}`, currentState);
  showPresetNotification(`Saved: ${name}`);

  return currentState;
}

// Load user presets from localStorage
function loadUserPresets() {
  const savedPresets = JSON.parse(localStorage.getItem('userPresets') || '{}');
  Object.assign(presets, savedPresets);
  console.log('ðŸ“‚ Loaded user presets:', savedPresets);
}

// Animate parameter to target value
function animateParameterTo(paramName, targetValue, duration = 1000) {
  const startTime = Date.now();
  let startValue;

  switch (paramName) {
    case 'zeta': startValue = zeta; break;
    case 'pmw': startValue = pmw; break;
    case 'unity': startValue = parseFloat(document.getElementById('unity').value); break;
    case 'flatness': startValue = parseFloat(document.getElementById('flatness').value); break;
    default: return;
  }

  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const easedProgress = smoothstep(0, 1, progress);

    const currentValue = startValue + (targetValue - startValue) * easedProgress;
    updateParameterFromMidi(paramName, currentValue * 127); // Convert back to MIDI range

    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  }

  animate();
}

// Handle MIDI actions (presets, functions)
function handleMidiAction(actionName, velocity = 127) {
  console.log(`ðŸŽ¹ MIDI Action: ${actionName} (vel: ${velocity})`);

  switch (actionName) {
    case 'center_me':
      document.getElementById('center-me').click();
      break;

    case 'portal_random':
      triggerRandomPortal();
      break;

    case 'toggle_shells':
      toggleShellVisibility();
      break;

    case 'reset_view':
      resetCameraView();
      break;

    case 'save_preset':
      const timestamp = new Date().toLocaleTimeString();
      saveCurrentStateAsPreset(`Live_${timestamp}`);
      break;

    default:
      // Check if it's a preset
      if (actionName.startsWith('preset_') && presets[actionName]) {
        applyPreset(actionName);
      } else {
        console.warn(`Unknown MIDI action: ${actionName}`);
      }
  }
}

// Extended parameter functions
function updateShellOpacity(value) {
  shells.forEach(shell => {
    shell.material.opacity = 0.05 + value * 0.2;
  });
}

function updateInstrumentScale(value) {
  if (instrumentMesh) {
    const scale = 0.5 + value * 1.5;
    instrumentMesh.scale.setScalar(scale);
  }
}

function updateDeformIntensity(value) {
  // This would affect the eigenmode displacement scaling
  // Implementation depends on how you want to scale the deformation
}

function triggerRandomPortal() {
  if (sprites.length > 0) {
    const randomSprite = sprites[Math.floor(Math.random() * sprites.length)];
    handleSpriteClick(randomSprite);
  }
}

function toggleShellVisibility() {
  shells.forEach(shell => {
    shell.visible = !shell.visible;
  });
}

function resetCameraView() {
  zeta = 0.3;
  document.getElementById('zeta').value = zeta;
  document.getElementById('zeta-val').textContent = zeta.toFixed(3);
  updateCamera();
  updateShells();
}

// Visual feedback functions
function showMidiActivity(paramName, value) {
  const indicator = document.getElementById('midi-indicator');
  const activity = document.getElementById('midi-activity');

  // Flash the indicator
  indicator.style.animation = 'none';
  indicator.offsetHeight; // Trigger reflow
  indicator.style.animation = 'midiFlash 0.2s ease-out';

  // Show activity popup
  activity.textContent = `${paramName}: ${(value * 100).toFixed(0)}%`;
  activity.classList.add('show');

  setTimeout(() => {
    activity.classList.remove('show');
  }, 1500);
}

function showPresetNotification(presetName) {
  const notification = document.getElementById('preset-notification');
  notification.textContent = `ðŸŽ¹ ${presetName}`;
  notification.classList.add('show');

  setTimeout(() => {
    notification.classList.remove('show');
  }, 2000);
}

function flashMidiStatus() {
  const status = document.getElementById('midi-status');
  const originalColor = status.style.color;
  status.style.color = '#10b981';
  setTimeout(() => {
    status.style.color = originalColor;
  }, 100);
}

// Multi-window synchronization functions
function initBroadcastChannel() {
  if (!window.BroadcastChannel) {
    console.warn('BroadcastChannel not supported, multi-window sync disabled');
    document.getElementById('multiwindow-status').textContent = 'Multi-Window: Not Supported';
    return;
  }

  broadcastChannel = new BroadcastChannel('signal-form-sync');

  broadcastChannel.onmessage = (event) => {
    const { type, data, windowId: senderWindowId, timestamp } = event.data;

    // Ignore messages from self or older messages
    if (senderWindowId === windowId || timestamp <= lastSyncTime) {
      return;
    }

    console.log(`ðŸ“¡ Received sync: ${type} from window ${senderWindowId}`);

    switch (type) {
      case 'parameter_update':
        handleRemoteParameterUpdate(data);
        break;

      case 'camera_update':
        handleRemoteCameraUpdate(data);
        break;

      case 'sprite_interaction':
        handleRemoteSpriteInteraction(data);
        break;

      case 'preset_applied':
        handleRemotePresetApplied(data);
        break;

      case 'window_heartbeat':
        handleWindowHeartbeat(senderWindowId, data);
        break;
    }

    lastSyncTime = timestamp;
  };

  // Send initial heartbeat
  sendWindowHeartbeat();

  // Regular heartbeat to maintain window list
  setInterval(sendWindowHeartbeat, 5000);

  console.log(`ðŸªŸ Multi-window sync initialized (Window ID: ${windowId})`);
}

function broadcastUpdate(type, data) {
  if (!broadcastChannel) return;

  const message = {
    type,
    data,
    windowId,
    timestamp: Date.now()
  };

  broadcastChannel.postMessage(message);
}

function sendWindowHeartbeat() {
  broadcastUpdate('window_heartbeat', {
    active: isWindowActive,
    zeta: zeta,
    pmw: pmw
  });
}

function handleWindowHeartbeat(senderWindowId, data) {
  connectedWindows.add(senderWindowId);
  updateMultiWindowStatus();

  // Clean up old windows after 10 seconds of no heartbeat
  setTimeout(() => {
    connectedWindows.delete(senderWindowId);
    updateMultiWindowStatus();
  }, 10000);
}

function updateMultiWindowStatus() {
  const status = document.getElementById('multiwindow-status');
  const windowCount = connectedWindows.size;

  if (windowCount === 1) {
    status.textContent = 'Multi-Window: Single';
    status.style.color = '#94a3b8';
  } else {
    const activeText = isWindowActive ? 'Active' : 'Idle';
    status.textContent = `Multi-Window: ${activeText} (${windowCount} windows)`;
    status.style.color = isWindowActive ? '#10b981' : '#f59e0b';
  }
}

function handleRemoteParameterUpdate(data) {
  const { parameter, value, source } = data;

  // Only apply if this window is not the active MIDI listener
  if (isWindowActive && source === 'midi') return;

  console.log(`ðŸ”„ Syncing ${parameter} = ${value} (from ${source})`);

  switch (parameter) {
    case 'zeta':
      zeta = value;
      document.getElementById('zeta').value = value;
      document.getElementById('zeta-val').textContent = value.toFixed(3);
      updateCamera();
      updateShells();
      break;

    case 'pmw':
      pmw = value;
      document.getElementById('pmw').value = value;
      document.getElementById('pmw-val').textContent = value.toFixed(3);
      break;

    case 'unity':
      document.getElementById('unity').value = value;
      document.getElementById('unity-val').textContent = value.toFixed(3);
      break;

    case 'flatness':
      document.getElementById('flatness').value = value;
      document.getElementById('flatness-val').textContent = value.toFixed(3);
      break;
  }
}

function handleRemoteCameraUpdate(data) {
  // Only sync camera if this window is idle
  if (isWindowActive) return;

  const { position, target, up } = data;
  if (camera && position) {
    camera.position.copy(position);
    camera.up.copy(up);
    camera.lookAt(target.x, target.y, target.z);
  }
}

function handleRemoteSpriteInteraction(data) {
  const { mediaId, type } = data;
  console.log(`ðŸŽ­ Remote sprite interaction: ${type} on ${mediaId}`);

  // Find and highlight the sprite briefly
  const sprite = sprites.find(s => s.userData.mediaItem.id === mediaId);
  if (sprite) {
    sprite.material.emissive.setHex(0x00ff00);
    setTimeout(() => {
      sprite.material.emissive.setHex(0x000000);
    }, 500);
  }
}

function handleRemotePresetApplied(data) {
  const { presetName } = data;
  showPresetNotification(`ðŸŒ ${presetName} (Remote)`);
}

// Window focus/blur handling for MIDI isolation
function setupWindowFocusHandling() {
  window.addEventListener('focus', () => {
    isWindowActive = true;
    updateMultiWindowStatus();
    console.log(`ðŸŽ¯ Window ${windowId} became active`);

    // Re-enable MIDI if this window becomes active
    if (midiWS && midiWS.readyState === WebSocket.OPEN) {
      document.getElementById('midi-status').style.color = '#34d399';
    }
  });

  window.addEventListener('blur', () => {
    isWindowActive = false;
    updateMultiWindowStatus();
    console.log(`ðŸ˜´ Window ${windowId} became idle`);
  });

  // Handle page visibility changes
  document.addEventListener('visibilitychange', () => {
    isWindowActive = !document.hidden;
    updateMultiWindowStatus();
  });
}

// MIDI WebSocket connection
function connectMidiWebSocket() {
  try {
    midiWS = new WebSocket('ws://localhost:7072/midi');

    midiWS.onopen = () => {
      document.getElementById('midi-status').textContent = 'MIDI: Connected';
      document.getElementById('midi-status').style.color = '#34d399';
      console.log('MIDI WebSocket connected');
    };

    midiWS.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);

        // Handle CC (Control Change) messages
        if (data.type === 'cc' && typeof data.cc === 'number' && typeof data.value === 'number') {
          // Only process MIDI if this window is active
          if (!isWindowActive) {
            console.log(`ðŸ”‡ Ignoring MIDI CC${data.cc} - window not active`);
            return;
          }

          const ccString = data.cc.toString();
          const paramName = midiMapping[ccString];

          if (paramName) {
            // Apply velocity sensitivity if provided
            let finalValue = data.value;
            if (typeof data.velocity === 'number' && data.velocity !== 127) {
              // Scale value based on velocity for expressive control
              const velocityFactor = data.velocity / 127.0;
              finalValue = data.value * velocityFactor;
            }

            updateParameterFromMidi(paramName, finalValue);
            console.log(`CC${data.cc} (${finalValue}) â†’ ${paramName} (${scaleMidiValue(finalValue).toFixed(3)})`);
            flashMidiStatus();

            // Broadcast parameter update to other windows
            broadcastUpdate('parameter_update', {
              parameter: paramName,
              value: scaleMidiValue(finalValue),
              source: 'midi'
            });
          } else {
            console.log(`Unmapped CC${data.cc}: ${data.value}`);
          }
        }

        // Handle Note On messages (for presets and actions)
        if (data.type === 'note_on' && typeof data.note === 'number' && data.velocity > 0) {
          // Only process MIDI if this window is active
          if (!isWindowActive) {
            console.log(`ðŸ”‡ Ignoring MIDI Note${data.note} - window not active`);
            return;
          }

          const noteString = data.note.toString();
          let actionName = null;

          // Check note mappings from config
          if (midiPanelConfig.note_mappings && midiPanelConfig.note_mappings[noteString]) {
            actionName = midiPanelConfig.note_mappings[noteString];
          }
          // Check panel-specific mappings (if panel type is specified)
          else if (midiPanelConfig.panel_configs) {
            for (const panelName in midiPanelConfig.panel_configs) {
              const panel = midiPanelConfig.panel_configs[panelName];
              if (panel.pads && panel.pads[noteString]) {
                actionName = panel.pads[noteString];
                break;
              }
              if (panel.notes && panel.notes[noteString]) {
                actionName = panel.notes[noteString];
                break;
              }
            }
          }

          if (actionName) {
            handleMidiAction(actionName, data.velocity);
            flashMidiStatus();

            // Broadcast preset actions to other windows
            if (actionName.startsWith('preset_')) {
              broadcastUpdate('preset_applied', {
                presetName: presets[actionName]?.name || actionName,
                actionName: actionName
              });
            }
          } else {
            console.log(`Unmapped Note${data.note}: velocity ${data.velocity}`);
          }
        }

        // Legacy support: direct parameter updates (backward compatibility)
        if (typeof data.zeta === 'number') {
          zeta = Math.max(0, Math.min(1, data.zeta));
          document.getElementById('zeta').value = zeta;
          document.getElementById('zeta-val').textContent = zeta.toFixed(3);
          updateCamera();
          updateShells();
        }

        if (typeof data.unity === 'number') {
          const unity = Math.max(0, Math.min(1, data.unity));
          document.getElementById('unity').value = unity;
          document.getElementById('unity-val').textContent = unity.toFixed(3);
          sendControl({ set: { unity: unity } });
        }

        if (typeof data.flatness === 'number') {
          const flatness = Math.max(0, Math.min(1, data.flatness));
          document.getElementById('flatness').value = flatness;
          document.getElementById('flatness-val').textContent = flatness.toFixed(3);
          sendControl({ set: { flatness: flatness } });
        }

        if (typeof data.pmw === 'number') {
          pmw = Math.max(0, Math.min(1, data.pmw));
          document.getElementById('pmw').value = pmw;
          document.getElementById('pmw-val').textContent = pmw.toFixed(3);
          sendControl({ set: { pmw: pmw } });
        }

        // Handle config reload message
        if (data.type === 'reload_config') {
          console.log('Reloading MIDI configuration...');
          await loadMidiMapping();
        }

      } catch (error) {
        console.warn('Error parsing MIDI data:', error);
      }
    };

    midiWS.onerror = () => {
      document.getElementById('midi-status').textContent = 'MIDI: Error';
      document.getElementById('midi-status').style.color = '#ef4444';
    };

    midiWS.onclose = () => {
      document.getElementById('midi-status').textContent = 'MIDI: Disconnected';
      document.getElementById('midi-status').style.color = '#f59e0b';
      // Reconnect after delay
      setTimeout(connectMidiWebSocket, 3000);
    };

  } catch (error) {
    console.error('MIDI WebSocket connection failed:', error);
    document.getElementById('midi-status').textContent = 'MIDI: Failed';
    document.getElementById('midi-status').style.color = '#ef4444';
  }
}

// Load collection data
async function loadCollection() {
  try {
    const response = await fetch(`${config.encoder_base}/collection/${config.collection_id}`);
    collection = await response.json();
    console.log('Collection loaded:', collection.media.length, 'items');
    createSprites();
  } catch (error) {
    console.error('Failed to load collection:', error);
  }
}

// Mouse interaction
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredSprite = null;

function onMouseMove(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(sprites);

  // Clear previous hover
  if (hoveredSprite) {
    hoveredSprite.material.emissive.setHex(0x000000);
    document.getElementById('sprite-card').style.display = 'none';
  }

  hoveredSprite = null;

  if (intersects.length > 0) {
    hoveredSprite = intersects[0].object;
    hoveredSprite.material.emissive.setHex(0x444444);

    // Show sprite card
    const card = document.getElementById('sprite-card');
    const media = hoveredSprite.userData.media;

    card.querySelector('.id').textContent = media.id;
    card.querySelector('.type').textContent = media.type;

    const palette = card.querySelector('.palette');
    palette.innerHTML = '';
    media.palette.forEach(color => {
      const colorDiv = document.createElement('div');
      colorDiv.className = 'color';
      colorDiv.style.backgroundColor = `rgb(${Math.floor(color*255)}, ${Math.floor(color*255)}, ${Math.floor(color*255)})`;
      palette.appendChild(colorDiv);
    });

    card.style.display = 'block';
    card.style.left = `${event.clientX + 10}px`;
    card.style.top = `${event.clientY + 10}px`;
  }
}

function onMouseClick(event) {
  if (hoveredSprite) {
    handleSpriteClick(hoveredSprite);
  }
}

function onWheel(event) {
  zeta = Math.max(0, Math.min(1, zeta + event.deltaY * 0.001));
  document.getElementById('zeta').value = zeta;
  document.getElementById('zeta-val').textContent = zeta.toFixed(3);
  updateCamera();
  updateShells();
  event.preventDefault();
}

// UI Controls
function setupControls() {
  const zetaSlider = document.getElementById('zeta');
  const pmwSlider = document.getElementById('pmw');
  const unitySlider = document.getElementById('unity');
  const flatnessSlider = document.getElementById('flatness');

  zetaSlider.addEventListener('input', (e) => {
    zeta = parseFloat(e.target.value);
    document.getElementById('zeta-val').textContent = zeta.toFixed(3);
    updateCamera();
    updateShells();

    // Broadcast parameter update
    broadcastUpdate('parameter_update', {
      parameter: 'zeta',
      value: zeta,
      source: 'slider'
    });
  });

  pmwSlider.addEventListener('input', (e) => {
    pmw = parseFloat(e.target.value);
    document.getElementById('pmw-val').textContent = pmw.toFixed(3);

    // Broadcast parameter update
    broadcastUpdate('parameter_update', {
      parameter: 'pmw',
      value: pmw,
      source: 'slider'
    });
  });

  unitySlider.addEventListener('input', (e) => {
    const unity = parseFloat(e.target.value);
    document.getElementById('unity-val').textContent = unity.toFixed(3);
    // Send control update
    sendControl({ set: { unity: unity } });

    // Broadcast parameter update
    broadcastUpdate('parameter_update', {
      parameter: 'unity',
      value: unity,
      source: 'slider'
    });
  });

  flatnessSlider.addEventListener('input', (e) => {
    const flatness = parseFloat(e.target.value);
    document.getElementById('flatness-val').textContent = flatness.toFixed(3);
    // Send control update
    sendControl({ set: { flatness: flatness } });

    // Broadcast parameter update
    broadcastUpdate('parameter_update', {
      parameter: 'flatness',
      value: flatness,
      source: 'slider'
    });
  });

  // Center Me button
  document.getElementById('center-me').addEventListener('click', () => {
    // Smooth transition to center
    const startZeta = zeta;
    const targetZeta = 1.0;
    const startTime = Date.now();
    const duration = 500; // ms

    function animateToCenter() {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easedProgress = smoothstep(0, 1, progress);

      zeta = lerp(startZeta, targetZeta, easedProgress);
      document.getElementById('zeta').value = zeta;
      document.getElementById('zeta-val').textContent = zeta.toFixed(3);

      updateCamera();
      updateShells();

      if (progress < 1) {
        requestAnimationFrame(animateToCenter);
      } else {
        // Set PMW to 1 and apply grounding
        pmw = 1.0;
        document.getElementById('pmw').value = pmw;
        document.getElementById('pmw-val').textContent = pmw.toFixed(3);
        sendControl({
          set: { pmw: 1.0, alpha_white: 0.8 },
          bias: { weights: [0.8, 0.1, 0.1] } // Flatten spectrum
        });
      }
    }

    animateToCenter();
  });
}

// Send control command
async function sendControl(command) {
  try {
    await fetch(config.http_control, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(command)
    });
  } catch (error) {
    console.error('Control send failed:', error);
  }
}

// Window resize
function onWindowResize() {
  const width = window.innerWidth;
  const height = window.innerHeight;

  renderer.setSize(width, height);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
}

// Animation loop
function animate() {
  updateCamera();
  updateInstrument();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

// Initialize
window.addEventListener('resize', onWindowResize);
window.addEventListener('mousemove', onMouseMove);
window.addEventListener('click', onMouseClick);
window.addEventListener('wheel', onWheel, { passive: false });

onWindowResize();
createShells();
createInstrument();
setupControls();
loadCollection();
loadMidiMapping(); // Load MIDI CC mapping configuration
loadUserPresets(); // Load saved user presets
startMidiConfigWatcher(); // Start watching for config changes
initBroadcastChannel(); // Initialize multi-window synchronization
setupWindowFocusHandling(); // Handle window focus/blur for MIDI isolation
connectWebSocket();
connectMidiWebSocket();
animate();

console.log('ðŸŒŠ Signalâ†’Form Spherical POV initialized');
console.log('Configuration:', config);

// Test CC scaling function
console.log('ðŸŽ›ï¸ MIDI CC Scaling Test:');
console.log('CC 0 â†’ ' + scaleMidiValue(0).toFixed(3));
console.log('CC 63 â†’ ' + scaleMidiValue(63).toFixed(3));
console.log('CC 127 â†’ ' + scaleMidiValue(127).toFixed(3));
console.log('MIDI Mapping:', midiMapping);

</script>
</body>
</html>
#!/usr/bin/env python3
"""
Fixed version of main_fixed_window.py with correct imports and initialization
"""

import sys
import os
import time
import threading
import numpy as np
import pygame
import pygame.midi
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QComboBox, QSlider, QCheckBox, QTextEdit,
    QSplitter, QMenuBar, QMenu, QDialog, QSpinBox, QGridLayout,
    QGroupBox, QFileDialog, QMessageBox, QProgressBar, QListWidget,
    QDoubleSpinBox
)
from PySide6.QtCore import QTimer, Signal, QObject, Qt, QSettings
from PySide6.QtGui import QAction, QFont
import pyvistaqt as pvqt
import pyvista as pv
from collections import deque

# Import the working components
from config import Config
from midi_handler import MidiHandler
from audio_analyzer import AudioAnalyzer
from light_effects import LightSource, generate_lighting_positions
from mesh_manager import MeshManager
from visualizer import MorphingVisualizer
from scene_manager import SceneManager

# Import the enhanced scene manager correctly
try:
    from enhanced_scene_manager import EnhancedSceneManager
    ENHANCED_SCENE_AVAILABLE = True
except ImportError:
    print("Warning: EnhancedSceneManager not available, using basic SceneManager")
    ENHANCED_SCENE_AVAILABLE = False

# Import the correct profiler
try:
    from profiler import PerformanceProfiler
    PROFILER_AVAILABLE = True
except ImportError:
    print("Warning: PerformanceProfiler not available")
    PROFILER_AVAILABLE = False

# Check for optional imports
try:
    import sounddevice as sd
    AUDIO_AVAILABLE = True
except ImportError:
    AUDIO_AVAILABLE = False
    print("Warning: Audio features disabled (sounddevice not installed)")

class PerformanceAwareMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.config = Config()
        self.setWindowTitle("MIDI Morphing Interface - Performance Monitored")
        
        # Initialize performance profiler if available
        if PROFILER_AVAILABLE:
            self.profiler = PerformanceProfiler()
            # Note: The simple profiler doesn't have start_monitoring method
            # It automatically records metrics when used
        else:
            self.profiler = None
        
        # Load settings
        self.settings = QSettings("MorphingVisualizer", "Config")
        self.config.load_from_settings(self.settings)
        
        # Initialize state
        self.current_mesh_key = "sphere"
        self.target_mesh_key = "icosahedron"
        self.active_notes = {}
        self.default_color = np.array([0.8, 0.8, 0.8])
        
        # Audio state
        self.audio_enabled = False
        self.audio_color_influence = 0.0
        self.audio_morph_influence = 0.0
        
        # Performance monitoring dialog
        self.performance_dialog = None
        self.config_dialog = None
        self.scene_config_dialog = None
        
        # Scene manager for multi-object compositions
        self.scene_manager = None
        
        # Setup components
        self.midi_handler = MidiHandler()
        self.audio_analyzer = AudioAnalyzer(self.config) if AUDIO_AVAILABLE else None
        
        # Initialize visualization and scene manager BEFORE UI setup
        self._initialize_visualization()
        
        self._setup_ui()
        self._setup_menu()
        self._setup_midi()
        self._setup_performance_monitoring()
        
        # Cleanup timer
        self.cleanup_timer = QTimer()
        self.cleanup_timer.timeout.connect(self._cleanup_expired_elements)
        self.cleanup_timer.start(5000)
        
        # Frame timing for FPS calculation
        self.render_timer = QTimer()
        self.render_timer.timeout.connect(self._frame_update)
        self.render_timer.start(16)  # ~60 FPS target
    
    def _initialize_visualization(self):
        """Initialize the visualization components."""
        # Create mesh manager
        self.mesh_manager = MeshManager()
        
        # Create plotter widget
        self.plotter = pvqt.QtInteractor()
        self.plotter.set_background(self.config.BACKGROUND_COLOR)
        self.plotter.enable_anti_aliasing()
        
        # Set up camera
        self.plotter.camera_position = 'xy'
        self.plotter.camera.position = (0, 0, 5)
        self.plotter.camera.focal_point = (0, 0, 0)
        self.plotter.camera.up = (0, 1, 0)
        
        # Create visualizer
        self.visualizer = MorphingVisualizer(
            self.mesh_manager,
            self.plotter,
            self.config
        )
        
        # Initialize scene manager based on availability
        initial_meshes = {
            'sphere': self.mesh_manager.create_sphere(),
            'cube': self.mesh_manager.create_cube(),
            'icosahedron': self.mesh_manager.create_icosahedron()
        }
        
        if ENHANCED_SCENE_AVAILABLE:
            self.scene_manager = EnhancedSceneManager(initial_meshes, self.plotter)
            print("✓ Enhanced Scene Manager initialized")
        else:
            self.scene_manager = SceneManager(initial_meshes, self.plotter)
            print("✓ Basic Scene Manager initialized")
        
        # Add initial mesh to scene
        current_mesh = self.mesh_manager.get_mesh(self.current_mesh_key)
        self.actor = self.plotter.add_mesh(
            current_mesh,
            color=self.default_color,
            smooth_shading=True,
            show_edges=False
        )
        
        # Set up lights
        self.lights = []
        self._setup_lights()
        
        print("✓ Visualization initialized")
    
    def _setup_ui(self):
        """Set up the user interface."""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout(central_widget)
        
        # Control panel
        control_panel = self._create_control_panel()
        
        # Create splitter for plotter and info panel
        splitter = QSplitter(Qt.Horizontal)
        splitter.addWidget(self.plotter.interactor)
        
        # Info panel
        info_widget = QWidget()
        info_layout = QVBoxLayout(info_widget)
        
        self.status_label = QLabel("Status: Ready")
        info_layout.addWidget(self.status_label)
        
        self.info_text = QTextEdit()
        self.info_text.setReadOnly(True)
        self.info_text.setMaximumHeight(200)
        info_layout.addWidget(self.info_text)
        
        # Performance metrics display
        if self.profiler:
            perf_group = QGroupBox("Performance Metrics")
            perf_layout = QVBoxLayout(perf_group)
            
            self.fps_label = QLabel("FPS: --")
            self.memory_label = QLabel("Memory: --")
            self.cpu_label = QLabel("CPU: --")
            
            perf_layout.addWidget(self.fps_label)
            perf_layout.addWidget(self.memory_label)
            perf_layout.addWidget(self.cpu_label)
            
            info_layout.addWidget(perf_group)
        
        splitter.addWidget(info_widget)
        splitter.setSizes([800, 300])
        
        main_layout.addWidget(control_panel)
        main_layout.addWidget(splitter)
        
        print("✓ UI setup complete")
    
    def _create_control_panel(self):
        """Create the control panel."""
        panel = QWidget()
        layout = QHBoxLayout(panel)
        
        # Mesh selection
        mesh_group = QGroupBox("Mesh Selection")
        mesh_layout = QGridLayout(mesh_group)
        
        mesh_layout.addWidget(QLabel("Current:"), 0, 0)
        self.current_mesh_combo = QComboBox()
        self.current_mesh_combo.addItems(self.mesh_manager.available_meshes)
        self.current_mesh_combo.setCurrentText(self.current_mesh_key)
        self.current_mesh_combo.currentTextChanged.connect(self._on_current_mesh_changed)
        mesh_layout.addWidget(self.current_mesh_combo, 0, 1)
        
        mesh_layout.addWidget(QLabel("Target:"), 1, 0)
        self.target_mesh_combo = QComboBox()
        self.target_mesh_combo.addItems(self.mesh_manager.available_meshes)
        self.target_mesh_combo.setCurrentText(self.target_mesh_key)
        self.target_mesh_combo.currentTextChanged.connect(self._on_target_mesh_changed)
        mesh_layout.addWidget(self.target_mesh_combo, 1, 1)
        
        layout.addWidget(mesh_group)
        
        # Audio controls
        if AUDIO_AVAILABLE:
            audio_group = QGroupBox("Audio Controls")
            audio_layout = QVBoxLayout(audio_group)
            
            self.audio_checkbox = QCheckBox("Enable Audio")
            self.audio_checkbox.toggled.connect(self._toggle_audio)
            audio_layout.addWidget(self.audio_checkbox)
            
            audio_layout.addWidget(QLabel("Color Influence:"))
            self.audio_color_slider = QSlider(Qt.Horizontal)
            self.audio_color_slider.setRange(0, 100)
            self.audio_color_slider.setValue(0)
            self.audio_color_slider.valueChanged.connect(
                lambda v: setattr(self, 'audio_color_influence', v / 100.0)
            )
            audio_layout.addWidget(self.audio_color_slider)
            
            audio_layout.addWidget(QLabel("Morph Influence:"))
            self.audio_morph_slider = QSlider(Qt.Horizontal)
            self.audio_morph_slider.setRange(0, 100)
            self.audio_morph_slider.setValue(0)
            self.audio_morph_slider.valueChanged.connect(
                lambda v: setattr(self, 'audio_morph_influence', v / 100.0)
            )
            audio_layout.addWidget(self.audio_morph_slider)
            
            layout.addWidget(audio_group)
        
        # Scene controls
        scene_group = QGroupBox("Scene Controls")
        scene_layout = QVBoxLayout(scene_group)
        
        add_object_btn = QPushButton("Add Object")
        add_object_btn.clicked.connect(self._add_scene_object)
        scene_layout.addWidget(add_object_btn)
        
        clear_scene_btn = QPushButton("Clear Scene")
        clear_scene_btn.clicked.connect(self._clear_scene)
        scene_layout.addWidget(clear_scene_btn)
        
        layout.addWidget(scene_group)
        
        layout.addStretch()
        
        return panel
    
    def _setup_menu(self):
        """Set up the menu bar."""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        save_config_action = QAction("Save Configuration", self)
        save_config_action.triggered.connect(self._save_configuration)
        file_menu.addAction(save_config_action)
        
        load_config_action = QAction("Load Configuration", self)
        load_config_action.triggered.connect(self._load_configuration)
        file_menu.addAction(load_config_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("Exit", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # View menu
        view_menu = menubar.addMenu("View")
        
        if self.profiler:
            perf_monitor_action = QAction("Performance Monitor", self)
            perf_monitor_action.triggered.connect(self._show_performance_monitor)
            view_menu.addAction(perf_monitor_action)
        
        config_action = QAction("Configuration", self)
        config_action.triggered.connect(self._show_config_dialog)
        view_menu.addAction(config_action)
        
        # Scene menu
        scene_menu = menubar.addMenu("Scene")
        
        if ENHANCED_SCENE_AVAILABLE and isinstance(self.scene_manager, EnhancedSceneManager):
            # Add enhanced scene manager menu items
            preset_menu = scene_menu.addMenu("Load Preset")
            
            # Note: We need to import InstrumentType if using enhanced features
            try:
                from enhanced_scene_manager import InstrumentType
                for instrument in InstrumentType:
                    action = preset_menu.addAction(instrument.value.title())
                    action.triggered.connect(
                        lambda checked, inst=instrument: self.scene_manager.load_instrument_preset(inst)
                    )
            except ImportError:
                pass
            
            scene_menu.addSeparator()
            
            record_action = QAction("Start Recording", self)
            record_action.triggered.connect(lambda: self.scene_manager.record_performance(60.0))
            scene_menu.addAction(record_action)
            
            stop_record_action = QAction("Stop Recording", self)
            stop_record_action.triggered.connect(self.scene_manager.stop_recording)
            scene_menu.addAction(stop_record_action)
    
    def _setup_midi(self):
        """Set up MIDI connections."""
        self.midi_handler.note_on.connect(self._handle_note_on)
        self.midi_handler.note_off.connect(self._handle_note_off)
        self.midi_handler.control_change.connect(self._handle_control_change)
        
        # Start MIDI handler
        if self.midi_handler.initialize():
            self.midi_handler.start()
            self.status_label.setText("Status: MIDI Connected")
            print("✓ MIDI handler started")
        else:
            self.status_label.setText("Status: No MIDI Device")
            print("✗ No MIDI device found")
    
    def _setup_lights(self):
        """Set up scene lighting."""
        # Clear existing lights
        for light in self.lights:
            self.plotter.remove_light(light)
        self.lights.clear()
        
        # Generate light positions
        positions = generate_lighting_positions(self.config.NUM_LIGHTS)
        
        # Create lights
        for i, pos in enumerate(positions):
            light = LightSource(
                position=pos,
                intensity=self.config.LIGHT_INTENSITY,
                color=self.config.LIGHT_COLOR
            )
            pv_light = light.to_pyvista_light()
            self.plotter.add_light(pv_light)
            self.lights.append(light)
    
    def _setup_performance_monitoring(self):
        """Set up performance monitoring."""
        if not self.profiler:
            return
        
        # Create timer for updating performance metrics
        self.perf_timer = QTimer()
        self.perf_timer.timeout.connect(self._update_performance_metrics)
        self.perf_timer.start(1000)  # Update every second
    
    def _update_performance_metrics(self):
        """Update performance metrics display."""
        if not self.profiler:
            return
        
        # Record system metrics
        self.profiler.record_system_metrics()
        
        # Get latest metrics
        cpu_metrics = self.profiler.get_stats('cpu_percent')
        memory_metrics = self.profiler.get_stats('memory_mb')
        
        # Update labels if they exist
        if hasattr(self, 'cpu_label'):
            if cpu_metrics and 'current' in cpu_metrics:
                self.cpu_label.setText(f"CPU: {cpu_metrics['current']:.1f}%")
        
        if hasattr(self, 'memory_label'):
            if memory_metrics and 'current' in memory_metrics:
                self.memory_label.setText(f"Memory: {memory_metrics['current']:.1f} MB")
    
    def _frame_update(self):
        """Called every frame for updates."""
        if self.profiler:
            self.profiler.increment_counter('frames')
            
            # Calculate FPS
            frame_count = self.profiler.counters.get('frames', 0)
            elapsed = time.time() - self.profiler.start_time
            if elapsed > 0:
                fps = frame_count / elapsed
                if hasattr(self, 'fps_label'):
                    self.fps_label.setText(f"FPS: {fps:.1f}")
        
        # Update scene if it has an update method
        if self.scene_manager:
            if hasattr(self.scene_manager, 'update'):
                self.scene_manager.update()
            elif hasattr(self.scene_manager, 'update_transitions'):
                # EnhancedSceneManager might use update_transitions
                self.scene_manager.update_transitions()
        
        # Update audio visualization if enabled
        if self.audio_enabled and self.audio_analyzer:
            self._update_audio_visualization()
        
        # Render
        self.plotter.render()
    
    def _handle_note_on(self, note, velocity):
        """Handle MIDI note on event."""
        if self.profiler:
            self.profiler.start_timer('note_on_handling')
        
        self.active_notes[note] = {
            'velocity': velocity,
            'start_time': time.time()
        }
        
        # Update visualization
        self.visualizer.handle_note_on(note, velocity)
        
        # Update scene manager if available
        if self.scene_manager:
            self.scene_manager.handle_note_event(note, velocity, True)
        
        # Enhanced scene manager specific handling
        if ENHANCED_SCENE_AVAILABLE and isinstance(self.scene_manager, EnhancedSceneManager):
            self.scene_manager.handle_midi_note(note, velocity, True)
        
        # Update info
        self.info_text.append(f"Note ON: {note} (velocity: {velocity})")
        
        if self.profiler:
            self.profiler.end_timer('note_on_handling')
    
    def _handle_note_off(self, note):
        """Handle MIDI note off event."""
        if note in self.active_notes:
            del self.active_notes[note]
        
        # Update visualization
        self.visualizer.handle_note_off(note)
        
        # Update scene manager
        if self.scene_manager:
            self.scene_manager.handle_note_event(note, 0, False)
        
        # Enhanced scene manager specific handling
        if ENHANCED_SCENE_AVAILABLE and isinstance(self.scene_manager, EnhancedSceneManager):
            self.scene_manager.handle_midi_note(note, 0, False)
        
        # Update info
        self.info_text.append(f"Note OFF: {note}")
    
    def _handle_control_change(self, control, value):
        """Handle MIDI control change."""
        self.info_text.append(f"Control: {control} = {value}")
        
        # Map control changes to parameters
        if control == 1:  # Modulation wheel
            self.visualizer.set_morph_amount(value / 127.0)
    
    def _on_current_mesh_changed(self, mesh_name):
        """Handle current mesh selection change."""
        self.current_mesh_key = mesh_name
        self.visualizer.set_current_mesh(mesh_name)
    
    def _on_target_mesh_changed(self, mesh_name):
        """Handle target mesh selection change."""
        self.target_mesh_key = mesh_name
        self.visualizer.set_target_mesh(mesh_name)
    
    def _toggle_audio(self, checked):
        """Toggle audio analysis."""
        self.audio_enabled = checked
        if checked and self.audio_analyzer:
            self.audio_analyzer.start()
        elif self.audio_analyzer:
            self.audio_analyzer.stop()
    
    def _update_audio_visualization(self):
        """Update visualization based on audio input."""
        if not self.audio_analyzer:
            return
        
        features = self.audio_analyzer.get_features()
        if features:
            # Apply audio influence to visualization
            if self.audio_color_influence > 0:
                # Modify colors based on audio
                pass
            
            if self.audio_morph_influence > 0:
                # Modify morph amount based on audio
                morph_mod = features.get('energy', 0) * self.audio_morph_influence
                self.visualizer.set_morph_amount(
                    self.visualizer.morph_amount + morph_mod
                )
    
    def _add_scene_object(self):
        """Add a new object to the scene."""
        if self.scene_manager:
            obj_id = f"object_{len(self.scene_manager.objects)}"
            mesh_name = self.current_mesh_key  # Use the mesh name string
            mesh = self.mesh_manager.get_mesh(mesh_name)
            position = np.random.uniform(-2, 2, 3)
            
            # Pass the mesh name as shape_type, not the mesh itself
            self.scene_manager.add_object(obj_id, mesh_name, position)
            self.info_text.append(f"Added object: {obj_id}")
    
    def _clear_scene(self):
        """Clear all objects from the scene."""
        if self.scene_manager:
            for obj_id in list(self.scene_manager.objects.keys()):
                self.scene_manager.remove_object(obj_id)
            self.info_text.append("Scene cleared")
    
    def _cleanup_expired_elements(self):
        """Clean up expired visual elements."""
        # This would clean up old particles, trails, etc.
        pass
    
    def _show_performance_monitor(self):
        """Show performance monitoring dialog."""
        if not self.profiler:
            return
        
        # Create simple dialog to show performance stats
        dialog = QDialog(self)
        dialog.setWindowTitle("Performance Monitor")
        dialog.setMinimumSize(400, 300)
        
        layout = QVBoxLayout(dialog)
        
        # Create text widget for report
        report_text = QTextEdit()
        report_text.setReadOnly(True)
        report_text.setFont(QFont("Courier", 10))
        
        # Generate and display report
        report = self.profiler.generate_report()
        report_text.setPlainText(report)
        
        layout.addWidget(report_text)
        
        # Refresh button
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(lambda: report_text.setPlainText(self.profiler.generate_report()))
        layout.addWidget(refresh_btn)
        
        dialog.show()
    
    def _show_config_dialog(self):
        """Show configuration dialog."""
        # This would show a dialog for editing configuration
        pass
    
    def _save_configuration(self):
        """Save current configuration."""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Configuration", "", "JSON Files (*.json)"
        )
        if filename:
            self.config.save_to_file(filename)
            QMessageBox.information(self, "Success", "Configuration saved")
    
    def _load_configuration(self):
        """Load configuration from file."""
        filename, _ = QFileDialog.getOpenFileName(
            self, "Load Configuration", "", "JSON Files (*.json)"
        )
        if filename:
            self.config.load_from_file(filename)
            QMessageBox.information(self, "Success", "Configuration loaded")
    
    def closeEvent(self, event):
        """Handle application close."""
        # Stop MIDI handler
        if self.midi_handler:
            self.midi_handler.stop()
        
        # Stop audio analyzer
        if self.audio_analyzer:
            self.audio_analyzer.stop()
        
        # Save settings
        self.config.save_to_settings(self.settings)
        
        event.accept()


def main():
    """Main entry point."""
    app = QApplication(sys.argv)
    app.setApplicationName("MIDI Morphing Visualizer")
    app.setOrganizationName("MorphingVisualizer")
    
    # Set application style
    app.setStyle("Fusion")
    
    # Create and show main window
    window = PerformanceAwareMainWindow()
    window.show()
    
    # Run application
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
